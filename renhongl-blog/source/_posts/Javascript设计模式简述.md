---
title: Javascript设计模式简述
date: 2017-04-25 21:25:12
tags:
	- Javascript
---

示例代码：[点击这里](https://github.com/renhongl/Summary/tree/master/demo/mode-demo)。

设计模式的主题总是把不变的事物和变化的事物分离开来。
<!--more-->

### 鸭子类型

如果它走起来像鸭子，叫起来也像鸭子，那么它就是鸭子。

### 多态

多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。

### 闭包

闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄漏，所以要尽量减少闭包的使用。

局部变量本来应该在函数退出的时候被解除饮用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。


跟闭包和内存泄漏有关系的地方是，使用闭包的同时，比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候有可能造成内存泄漏。但这并非闭包问题，也并非Javascript问题。

**注：** 当代码中需要全局变量时，可以使用闭包，将这个变量封装在一个函数中，那这个函数就封装了一个独立的功能，不再依赖外部的变量。

### 函数柯里化（function currying）

currying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚传入的参数在函数形成的闭包中被保存起来。待到函数真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

### uncurrying

当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。

同理，一个对象也未必只有使用它自身的方法。通过call和apply方法可以让对象去借用一个原本不属于它的方法。


### 函数节流

在一些情况下，函数的触发不是由用户直接控制的，在这些情景下，函数可能被非常频繁的调用，而造成大的性能问题。

例如在window的resize事件中，或者在div拖动事件中，会频繁的触发这些事件，并且DOM相关的操作非常消耗性能，这时浏览器可能会出现卡顿现象。

以上现象我们可以使用setTimeout来实现每隔固定时间来触发事件，如果过于频繁，将忽略那次的事件。

代码流程：

    var resize = function(callback, interval) {
        var timer,
            firstTime = true;
        return function() {
            var args = arguments,
                self = this;
            if(firstTime) {
                callback.apply(self, args);
                return false;
            }
            if(timer) {
                return false;
            }
            timer = setTimeout(function() {
                clearTimeout(timer);
                timer = null;
                callback.apply(self, args);
            }, interval || 500)
        }
    };

    window.onresize = resize(function() {
        console.log('resized', Date.now());
    }, 1000);


### 分时函数

比如在加载QQ列表时，需要增加成百上千个DOM节点作为好友，在短时间内添加大量DOM也会让浏览器卡顿，我们可以使用分批进行的方法，比如一秒创建1000个节点，改为每隔200毫秒创建10个节点。


### 原型模式

类并不是必须的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。

原型模式不但是一种设计模式，也被称为一种编程泛型。

ECMAScript5提供了Object.create方法，可以用来克隆对象。

但是create方法性能不如 var obj = {} 或者 var obj = new Object();

以上两种替代方式，内部都是克隆原型而得到对象。

**注：** Javascript中的根对象是Object，所有的对象都从根对象克隆而来。

### 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

推荐使用惰性单例的方式创建，即在需要时才创建单例对象。并且需要把不变的部分隔离出来，把管理单例的逻辑和创建对象的逻辑分开，这两个方法可以独立变化而不互相影响。当它们连接在一起时，就完成了创建唯一实例对象的功能。

### 策略模式

定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。

一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类context，context接受客户的请求，随后把请求委托给某一个策略类。

策略模式可以消除程序中大片的条件分支语句。

### 代理模式

代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。

代理和本体接口保持一致，那么用户可以放心的请求代理，他只关心是否得到想要的结果；在任何使用本体的地方都可以替换成使用代理。

虚拟代理：例如实现图片预加载、合并http请求。

缓存代理：例如缓存ajax异步请求的数据，下次再打开同一页的时候，便可以直接使用之前的数据。


### 迭代器模式

迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。

外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。

中止迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。

### 发布-订阅模式

又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。

推荐使用全局的发布-订阅对象，并且增加可以先发布再订阅的方法，以及实现命名空间的功能。

### 命令模式

命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

### 组合模式

组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。

### 模板方法模式

假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬到另外一个单一的地方，模板方法就是为解决这个问题而生的。

在模板方法中，可以使用钩子方法来隔离变化。我们在父类种容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要挂钩，这由子类自行决定。

模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法中，而子类的方法具体怎么实现则是可变的，把这部分变化的逻辑封装到子类中。

### 享元模式

享元模式是一种用于性能优化的模式。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。

使用享元模式的关键是如何区别内部状态和外部状态，可以被对象共享的属性通常被划分为内部状态。

### 职责链模式

### 中介者模式

### 装饰者模式

### 状态模式

### 适配器模式