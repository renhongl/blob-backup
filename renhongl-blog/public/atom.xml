<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柚子</title>
  <icon>https://www.gravatar.com/avatar/c85963e74dd84011560354e6556d6dc3</icon>
  <subtitle>如果你今天对自己满意，明天就会被淘汰。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/renhongl/"/>
  <updated>2018-06-18T13:58:33.193Z</updated>
  <id>https://github.com/renhongl/</id>
  
  <author>
    <name>柚子</name>
    <email>1075220132@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://github.com/renhongl/2018/06/18/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/renhongl/2018/06/18/函数式编程/</id>
    <published>2018-06-18T13:57:52.000Z</published>
    <updated>2018-06-18T13:58:33.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><a id="more"></a><ul><li><p>简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。<br>它属于”结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p></li><li><p>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。<br>最主要的特征是，函数是第一等公民。<br>强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。<br>只有纯的、没有副作用的函数，才是合格的函数。</p></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>函数是”第一等公民”<br>指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p></li><li><p>只用”表达式”，不用”语句”<br>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。<br>函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p></li><li><p>没有”副作用”<br>指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。<br>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p></li><li><p>不修改状态<br>在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。</p></li></ol><ol start="5"><li>引用透明<br>指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</li></ol><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ol><li><p>代码简洁，开发快速<br>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p></li><li><p>接近自然语言，易于理解<br>函数式编程的自由度很高，可以写出很接近自然语言的代码。</p></li><li><p>更方便的代码管理<br>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。<br>因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</p></li></ol><ol start="4"><li><p>易于”并发编程”<br>函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，<br>被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。</p></li><li><p>代码的热升级<br>函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://github.com/renhongl/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>职业发展方向</title>
    <link href="https://github.com/renhongl/2018/06/18/career-development/"/>
    <id>https://github.com/renhongl/2018/06/18/career-development/</id>
    <published>2018-06-18T13:16:52.000Z</published>
    <updated>2018-06-18T13:33:11.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术类人员的职业发展方向"><a href="#技术类人员的职业发展方向" class="headerlink" title="技术类人员的职业发展方向"></a>技术类人员的职业发展方向</h3><a id="more"></a><p>几乎每 个企业都需要技术人员的支持，生产制造型企业需要现场生产控制和工艺流程方面的技术人才；IT等高科技行业需要大量软件研发和设备维护的硬件工程师；房地 产、建筑工程领域需要建筑设计师、土木工程师和施工技术人员。此外，不论是国企、民营企业还是外资公司，都需要大量的基础技术工人。甚至很多在豪华写字楼 office内工作的白领，从事的工作都是和技术相关的。</p><p>　　不过，一个严峻的现实是，大量的技术类人员对自己的职业定位和职业生涯规划显得非常迷茫和困惑。中国有句古话：劳心者治人，劳力者治于人。与管理类岗 位相比，技术人员往往被人看低一等，他们虽然从事着非常重要、繁琐的技术性工作，但更多的是扮演着幕后英雄的角色。在社会地位、经济收入方面与分光无限的 各级管理层普遍存在差距，这一现实造就了技术人员的巨大心理落差。第二个造成职业规划困惑的原因是部分技术性工作的局限性。拿IT行业来说，由于技术和知 识更新的速度太快，软件开放人员普遍被认为是吃“青春饭”的职位，谁学习的更快、谁的精力更旺盛、谁更能熬夜，谁就更有竞争力，因为这时经验已经不再重 要。如果超过35岁还从事软件开发的话，将很难在本职岗位取得突破。</p><p>　　那么，对于技术类人员来说，难道他们的职业发展前景真的如此黯淡？事实当然不会如此悲观，做技术工作同样有着非常广阔的空间，当然，关键一点你要令自己的视野更开阔些，从长远的角度来看待这个问题。根据我的经验，技术人员的职业方向可以有以下几个选择： </p><p>　　方向一、成为项目经理</p><p>　　对于很多从事技术方面工作的人员来说，发展成为项目经理是一个相当好的工作。项目管理工作既需要扎实的技术背景支持，又涉及多方面的管理工作，最适合 那些技术出身但又不甘于只做技术工作的人员。成为项目经理，一方面可以充分发挥技术人员的专业优势，同时又可在团队管理、协调各方资源、内外部沟通等工作 中体验和发挥作为管理者的角色和作用，从而让自身价值更为充分的实现和得到认可。优秀的项目管理人才，也是今后很长时期内的一个热门职业方向。</p><p>　　方向二、成为行业资深专家</p><p>　　如果的确非常喜爱技术工作，而不擅长和喜欢与人沟通，则可以完全专注于自身的领域，以发展成为行业资深专家为方向和目标，当然，这一发展过程可能会比 较漫长，任何一个领域的顶尖技术人才都需要长期的行业经验的累积和个人孜孜不倦的投入。不过这类人才的一个优势是越老越吃香，当别人随着年龄的逐步增长而 开始担心饭碗问题时，你则渐入佳境，开始进入职业发展的黄金时期。</p><p>　　方向三、成为研发经理或技术总监</p><p>　　事实上，在某些行业和企业，技术研发人员的地位是非常高的。譬如在微软、诺基亚、华为等IT产业，技术的支持和研发的速度，成为企业利润增长的最主要 来源，在这些行业，技术研发部门就是企业的主战场。在不少国企和政府部门，也非常重视科技和技术工作，例如，我所知道的广州市市政园林局，就设有总工程 师、副总工程师等技术职位，其中总工程师的职务级别相当于副局级，在这种氛围影响下，技术岗位人才和行政领导同样受人尊敬。所以，在一个尊重和重视技术工 作的行业和企业中，发展成为研发经理、技术总监或总工程师都是一个很好的选择。</p><p>　　方向四、做技术型销售和服务</p><p>　　技术工作的领域其实非常广泛，如果感觉纯技术工作发展潜力不大，可以考虑转向做销售或技术支持方面。华为、中兴等通信技术公司的销售人员，很少是不具 有专业技术背景的；甲骨文等软件巨头的市场推广，第一步常常是从销售工程师拜访客户开始的。这类高价值、高科技的产品销售推广，非常需要具有丰富技术经验 的销售人员。</p><p>　　技术人员转向售后服务，也是非常有前途的。我认识的一个朋友，大学是施工机械专业，毕业后一直在市政工程行业做非开挖顶管施工，在几年的工作中积累了 丰富的地下顶进设备的应用和维修经验，一个合适的机会跳槽到著名的顶管设备生产商－德国海瑞克公司，成为其售后服务工程师，工作上得心应手，收入也有了数 倍的增长。 </p><p>　　方向五、转向管理岗位</p><p>　　总有一些人，虽然是理工科出身、从事着技术岗位工作，但他们似乎天生就是具有管理天赋的人。这些人会在工作中逐步展现出管理潜质和优秀的领导能力，他 们往往更喜欢跟人打交道，更喜欢与外界沟通。在这种条件下，以技术经验为基础和依托，适当补充学习些管理方面的知识，例如可以在职攻读MBA，假以时日， 完全可以成长为出色的职业经理人。</p><p>　　方向六、高级技术操作人员</p><p>　　刚才所谈的职业发展方向，适用群体多为高校理工专业出身的人士，但对于数量众多的中等专科学校、技校毕业的一线技术工人来说，成为行业技术专家或研发总监的机会显然非常微小。这一群体的职业人士，最佳的技术发展路线是立足本职岗位，成为高级操作型技术人员。</p><p>　　广州市2006年出台的各类岗位工资指导价格中，高级技师就业的工资比博士还要高出500元。出现这一现象的原因很简单，从全国层面来说，产业工人数 量虽然巨大，但高级技工的比例却非常小，“高级技工”的缺乏已经成为制约许多企业发展的“瓶颈”。但随着政策环境、企业认识角度和培育机制方面的不断改 善，这一现象将逐步得到改变，所以成为中高级技师将是一个非常有前途的职业发展方向。</p><p>　　最后，我再次拿IT行业为例来具体谈谈技术人员的职业轨迹。</p><p>　　IT(Information Technology)行业的分类相当复杂，我这里仅仅分析最典型的三个部分:</p><p>　　第一部分是软件开发，通俗来说就是编程。实际上我认为真正的软件开发人员和制鞋工厂中的工人处在一个地位，是企业产品的最终生产者(当然这里没有贬义)。 </p><p>　　第二个部分是MIS: Management Information Service/System（管理信息系统），主要负责基础IT建设、网络、通讯、软硬件支持、简单开发等职能，为公司其他部门提供IT基础服务。</p><p>　　第三部分是ERP: Enterprise Resource Planning（企业资源计划系统），主要涉及企业管理类软件实施、维护、管理。通过是引入信息化手段在企业现实的实现企业的资源管理，协调企业各方面 的生产运作，它对业务的规范和企业的管理机制有很大的依赖。</p><p>　　让我们来分别看看这三部分人员的职业发展空间：</p><p>　　1. 开发人员</p><p>　　我的观点是，在中小企业做纯粹的软件开发很可能走上一条不归路，长期从事开发的人一般处世能力不足，升任管理人员的机会不大。而还有一个更重要的问题 是中国目前开发行业的环境很不好，正如我之前谈到的基本是在吃青春饭，30往后就很难做下去了。而在美国40岁的开发人员是正吃香的年龄。虽然可能业务越 来越精，但可能会离IT越来越远，向纯蓝领工人发展。</p><p>　　如果真的要做开发，应该找一个更好的平台，最好是进入跨国企业或国内龙头企业。如果数据方面的技术很强，可以考虑转向互联网搜索方向；如果在电子和通信设备方面有优势，可以从简单的程序开发转向通信产品的开发。</p><p>　　2. MIS人员</p><p>　　MIS内容广泛，可从事的职业很多:网管、技术支持等，而且通过努力可以得到提升成为小小的主管(当然要有自身的素质)，进而成为MIS Manager，但做到MIS Manager基本也就到头了，不过倒是可以考虑转到不同的行业或企业做MIS。</p><p>　　同样是做IT服务，在不同公司内IT部门的地位还是非常巨大的。就我所了解的，雅芳（中国）公司的IT部门就有100多人，在公司总部的各职能部门中 的地位相当高；而南方航空公司的IT部门竟然达到800多人，这个规模已经远远超过一般的IT公司，其IT部门的总裁也是公司决策层的重要成员。所以，在 这些公司内做IT技术支持工作，既避免了纯编程式的软件开发人员遇到的“人老珠黄”的被动局面，也不必担心IT产业泡沫破灭而产生的生存危机。</p><p>　　3. ERP类人员</p><p>　　从事企业管理类软件的人员一般起点比较高(公司的起点就比较高)，要求对财务、生产、销售等流程都有清楚地认识，从业人员不一定为IT出身，而有可能 是财务人员或理工科人员等转行而来。IT的迅速发展和企业经营领域的不断拓展，为ERP的推广和发展创造了良好的发展空间。事实上，一个从事企业管理类软 件的技术人员完全可以胜任一个企业的管理者，在这一领域技术人员的前景可以说是非常广阔的。</p><p>　　我认识的一位朋友，本科读的是工业装备控制专业，毕业后一直从事ERP方面的应用推广和管理咨询，虽然他对纯粹的IT技术了解并不是特别深刻，但在 ERP系统在企业中的应用方面经验非常丰富，在别人眼中他更像是一名管理咨询师，五年下来已经是这一领域的专家级人物，在个人收入方面也非常可观。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;技术类人员的职业发展方向&quot;&gt;&lt;a href=&quot;#技术类人员的职业发展方向&quot; class=&quot;headerlink&quot; title=&quot;技术类人员的职业发展方向&quot;&gt;&lt;/a&gt;技术类人员的职业发展方向&lt;/h3&gt;
    
    </summary>
    
    
      <category term="综合技能" scheme="https://github.com/renhongl/tags/%E7%BB%BC%E5%90%88%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>技术选型</title>
    <link href="https://github.com/renhongl/2018/06/18/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    <id>https://github.com/renhongl/2018/06/18/技术选型/</id>
    <published>2018-06-18T12:16:52.000Z</published>
    <updated>2018-06-18T13:28:44.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="做技术选型时，要注意些什么？"><a href="#做技术选型时，要注意些什么？" class="headerlink" title="做技术选型时，要注意些什么？"></a>做技术选型时，要注意些什么？</h3><p>对于技术选型，有些建议供你参考。此外，还有一个实践案例供你借鉴。</p><a id="more"></a><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>对于一名热爱技术的工程师来说，很容易出现非常热衷于使用新技术的情况，记得有一次和一位做平台应用的同事闲聊，他问我最近在搞什么，我说在研究 Hadoop，正在用 MapReduce 处理海量图片的智能分析，他一脸羡慕：“能搞新技术，真好！”。</p><p>作为一名工程师，我可以理解大家的心情，我们都是热爱尝试新技术、抛弃过时技术的人。但是首先得明确，到底技术是不是过时的，还是仅仅是你认为它过时了。这篇文章我想谈谈我对技术选型的理解。</p><p>这篇文章不仅仅是写给工程师，更多是写给技术团队负责人（大多数也是从工程师升职上去的，起初思维和工程师差距不大），因为你们具体负责技术选型的方向、方法、过程、结论明确。</p><h4 id="技术选型的注意事项"><a href="#技术选型的注意事项" class="headerlink" title="技术选型的注意事项"></a>技术选型的注意事项</h4><p>先来看看软件开发领域的变化，变化实在是太快了。在 JavaScript 里，几乎每天都有新框架诞生。Node.js(关键词：事件编程），React 编程，Meteor.js（关键词：共享状态），前端 MVC，React.js…… 你可以随便举例。软件工程领域里新概念也层出不穷：领域驱动开发，六边形架构理论，DCI 架构（数据 - 场景 - 交互）。</p><p>洛克希德•马丁公司的著名飞机设计师凯利•约翰逊所提出的 KISS 原则，指出架构设计能简单绝不复杂，坚决砍掉任何华而不实的设计，不要因为 3 年后可能怎样甚至是一些现实中根本无法出现的场景，加入到当下的架构设计中，导致系统无比复杂。有时候看似引入的是一个很简单很容易解决的问题，可能在具体的执行过程中带来一系列不必要的麻烦。技术选型其实遇到的问题和系统架构设计类似，也容易出现人为因素导致的偏差，进而出现和系统架构过度设计类似的麻烦。</p><p>对于技术选型，有以下几个建议：</p><h4 id="选择你最熟悉的技术"><a href="#选择你最熟悉的技术" class="headerlink" title="选择你最熟悉的技术"></a>选择你最熟悉的技术</h4><p>记得看过一篇文章，里面提到一个新项目最好不要使用超过 30% 的新技术，我觉得这有一定道理，因为对于你完全不知道的技术，你不可能控制使用过程中出现的风险。我在技术管理中的向下管理里提起过，任何一位技术 Leader，如果你不能得到下属的技术尊重，你必将受到惩罚。</p><p>也不能说完全不能使用新技术，前几天和朋友聊天，他提到了另外一位总监下属有几个人转岗了，都是技术牛人，最主要的原因是这位总监坚决排斥新技术，坚持自己熟悉 的十年前的框架和编写代码规范。他对于一个新技术的天然不信任，在技术接受程度还不够高，并且认为公司内没有人能吃透这个技术的情况下，不愿意让自己的业务做第一个吃螃蟹的人，这种做法不能说完全错误，至少对于他自己来说很稳健，但是却压制了一些有追求人的内心。</p><p>谨慎是个美德，不过如果在一个非常追求速度的业务里，这可能也意味着过于保守，会延误时机。</p><p>那我们应该怎样做到选择技术呢？我认为，在选择技术时有两个大原则。第一，要取其长避其短；第二，要关注技术的发展前景。每种技术都是有它特定的适用场景，开发者经常犯的错误就是盲目追新，当一个新语言、框架、工具出现后，特别是开发者自己学会了这种新技术后，就会有种“拿着锤子找钉子”的感觉，将新技术滥用于各种项目。</p><p>记住，技术选型是稳定压倒一切。</p><h4 id="选择拥有强大社区支撑的开源技术"><a href="#选择拥有强大社区支撑的开源技术" class="headerlink" title="选择拥有强大社区支撑的开源技术"></a>选择拥有强大社区支撑的开源技术</h4><p>没有人喜欢“alone in the dark”的感觉，同样，也很少有工程师喜欢孤独地面对代码缺陷。我们之所以喜欢在 Apache 上挑选合适的新框架尝试使用，是因为 Apache 始终保持运作着强大的社区，每天都有很多新建的框架，也设计了一整套生命周期管理标准，让一个项目能够从孵化项目逐渐一步步地走向顶级项目。除了像 Apache 这样的社区，我们也可以评估是否存在一些商业公司提供针对该技术或者框架的有偿支撑，一般来说，有公司愿意围绕该技术布局，也能说明确实存在使用空间。例如 Apache Cassandra，目前就有 Datastax 和 LastPickle 两家公司对它提供技术指导和有偿辅助软件支撑。</p><p>其实看一项技术活不活跃，只要去 StackOverflow 这样的网站看看提问的人多不多就知道了。</p><h4 id="确保技术前进步伐"><a href="#确保技术前进步伐" class="headerlink" title="确保技术前进步伐"></a>确保技术前进步伐</h4><p>选择一个技术的最低标准是，技术的生命周期必须显著长于项目的生命周期。</p><p>为什么需要确保所选择的技术不断前进？因为这个世界是发展的，科技发展更是非常得快速，你可以看看，所有的成功的科技公司都是因为跑在了别人前面，而不是慢悠悠的工作态度，这就是科技界的残酷，也正是为什么 FaceBook 办公室里贴着：“要么做到最好，要么死亡”。</p><p>技术的前进不仅仅取决于它本身，而是和大环境发展、上下游用户也密切相关。比如 AI，60 年代其实就已经提出了相应概念，为什么直到今年才进入发展元年？因为芯片的计算效率、数据样本规模没有达到要求。而 Functional Language 为什么这么多年一直默默无闻，而从前几年开始逐渐盛行？因为机器学习来了，AI 来了，它们有了用武之地。</p><p>总的来说，你需要使用你所选择的软件技术，快速地实现应用程序的构建。记住一句话：好的技术栈永远跑在用户需求前面。</p><h4 id="学会从业务端开始思考"><a href="#学会从业务端开始思考" class="headerlink" title="学会从业务端开始思考"></a>学会从业务端开始思考</h4><p>技术选型必须贴着业务来选择，不同业务阶段会有不同的选型方式。处于初创期的业务，选型的基准是灵活。只要一个技术够用并且开发效率足够高，那么就可以选择它。初创的业务往往带有风险性和不确定性，朝令夕改、反复试错是常态，技术必须适应业务的节奏，然后才是其他方面。等业务进入稳定期，选型的基准是可靠。技术始终是业务的基石，当业务稳定了技术不稳，那就会成为业务的一块短板，就必须要修正。当业务进入维护期，选型的基准是妥协。代码永远有变乱的趋势，一般经过一两年就有必要对代码来一次大一点的重构。在这种时候，必须得正视各种遗留代码的迁移成本，如果改变技术选型会带来遗留代码重写，这背后带来的代价业务无法承受，那么我们就不得不考虑在现有技术选型之上做一些小修小补或者螺旋式上升的重构。</p><p>正因为技术选型和业务相关，我们能够观察到一些很明显的现象：新技术往往被早期创业团队或大公司的新兴业务使用；中大型公司的核心业务则更倾向于用一些稳定了几年的技术；一个公司如果长期使用一种技术，就会倾向于一直使用下去，甚至连版本都不更新的使用下去。这现象背后都是有道理的。</p><p>回到我们的主题，学会从业务端思考。首先我们需要充分地理解业务，理解用户需求，理解当下需要解决的首要问题，以及可能的风险有哪些，再将目标进行分解，进行具体的技术选型、模型设计、架构设计。</p><p>举个例子。假设我们需要解决的核心问题是并发，则可以通过各种缓存手段（本地缓存、分布式缓存），来提高查询的吞吐，这样虽然会一定程度上需要在数据一致性上做出牺牲，由强一致性变为最终一致性。</p><p>但是，如果数据一致性不是核心需要解决的问题，那么，此问题的优先级则可以先放一放，反过来如果核心问题变为数据的一致性，如交易系统，那么再怎么强调数据的一致性都不为过，由于分布式环境下为了应对高并发的写入以及海量数据的存储，通常需要对关系型数据库进行分库分表扩展，这也给数据一致性带来了很大的挑战，原本的单库事务的强一致性保障，在这个时候升级为跨库的分布式事务，而通过二阶段或者三阶段提交所保障的分布式事务，由于分布式事务管理器与资源管理器之间的多次网络通信成本，吞吐及效率上很难满足高并发场景下的要求，而这实际上对于交易系统来说，又是一个很难回避的问题。</p><p>因此，大家又想出很多的招来解决这个问题，通过可靠消息系统来保障不失为一种方式，变同步为异步，但是，又引入新的问题，消息系统为保证不丢消息，则很难保证消息的顺序性以及是否重复投递，这样作为消息的接收方，则需要保障消息处理的幂等性，以及对消息去重。</p><h4 id="先验证，后使用"><a href="#先验证，后使用" class="headerlink" title="先验证，后使用"></a>先验证，后使用</h4><p>对于未经验证的新技术、新理念的引入一定要慎重，一定要在全方位的验证过后，再大规模的使用。新技术、新理念的出现，自然有它的诱惑，慎重并不代表保守，技术总是在不断前进，拥抱变化本身没有问题，但是引入不成熟的技术看似能带来短期的收益，但是它的风险或者是后期的成本可能远远大于收益。</p><h4 id="重视经验"><a href="#重视经验" class="headerlink" title="重视经验"></a>重视经验</h4><p>技术选型是个很需要经验的活，得有大量的信息积累和输入，再根据具体现实情况输出一个结果。我们在选型的时候最忌讳的是临时抱佛脚、用网上收集一些碎片知识来决策，这是非常危险的，我们得确保自己所有思考都是基于以前的事实，还要弄清楚这些事实背后的假设，这都需要让知识内化形成经验。</p><p>经验的本质是什么，有什么方法能够确定自己的经验增长了，而不是不断在重复一些很熟悉的东西。我现在的结论是，经验等于知识索引的完备程度。</p><p>我们一生中会积累很多的知识，如果把我们的大脑比作数据库的话，那我们一定有一部分脑存储贡献给了内容的索引，它能帮助我们将关联知识更快的取出来，并且辅助决策。经验增长等同于我们知识索引的增长，意味着我们能轻易的调动更多的关联知识来做更全面的决策。</p><p>要想建立好这个知识索引，我们得保持技术敏感性和广度，也就是要做到持续的信息输入、内化，并发现信息之间的关联性，建立索引，记下来。说起来容易，做起来还是挺有难度的。</p><p>首先难在信息输入量大，忘记了怎么办。我们的大脑不是磁盘，不常用的知识就会忘记，忘记了就跟没看过是一回事。我的经验是一定要对知识进行压缩，记住的是最关键的细节，并且反复的去回味这个细节。</p><h4 id="我的实际案例"><a href="#我的实际案例" class="headerlink" title="我的实际案例"></a>我的实际案例</h4><p>去年我做了一次对于分布式数据库的选型工作。我们为什么要做这次选型？因为存在明确的需求，我们需要解决大规模高并发数据存储，单次数据不大，但是存储频率、读取频率都很高，并且要确保不丢失数据，这样的需求对于关系型数据库来说，出现了性能瓶颈。</p><p>我对于技术选型有自己的一套方法论，我知道，我不可能什么技术都懂，所以我会按照自己的这套方法论来具体执行，避免出现选型误差。我的步骤是：“列出需求”-“细分需求”-“明确搜索方向”-“网络搜索”-“明确评判标准”-“分头执行”-“汇总材料”-“初步选择”-“进一步调研”-“会议评审”-“做出决定”。这些步骤太多，需求我已经介绍了，这里具体再讲讲我这一次是如何进入下一步选型的，也就是“初步选择”-“进一步调研”之间的过程。</p><p>我通过网络搜索（进入 Google，搜索 Distributed Database、NoSQL Database 等关键词），我找到了如下这些国内外专家推荐的分布式数据库，他们的基本描述如下所示：</p><p>HyperTable： 一个开源、高性能、可伸缩的数据库，它采用与 Google 的 BigTable 相似的模型。该数据库数据按主键在物理上排序，适用于数据分析领域，采用 C++ 编写，可以运行在 HDFS 上面。该数据库受到 GPLV3 协议约束，考虑到它和 HBase 从系统架构上来说很相似，但是协议约束较多，所以放弃调研，转而调研 HBase。</p><p>HBase： 即 Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，采用主 / 从架构设计，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。它是 Google BigTable 的开源实现。</p><p>VoltDB： 一个内存数据库，提供了 NoSQL 数据库的可伸缩性和传统关系型数据库系统的 ACID 一致性，支持单节点 53000TPS/s。该数据库受到 GPLV3 协议约束。VoltDB 有两个版本，一个开源社区版本和一个付费企业版本。付费企业版本除包含了所有开源社区版的功能，还有些其他特点，诸如计算机集群管理控制台、系统性能仪表盘、数据库宕机恢复、在线数据库 Schema 修改、在线数据库节点重新加入、JDBC 和 OLAP 导出支持、命令日志。</p><p>由于该框架开源社区不活跃，主导者更加希望使用付费版本，所以决定放弃它，转而调研类似的 Redis。</p><p>CloudData： 一个结构化数据库，没有中文资料，从系统架构、功能上分析，类似于 MongoDB。</p><p>Gridool： 一种基于 MapReduce 原理设计的网格计算引擎，不支持数据存储，所以放弃。</p><p>Ddb-query-optimizer： 找不到资料，放弃。</p><p>Cages： 基于 ZooKeeper 实现数据协调 / 同步，不仅能性数据分布式存储，放弃。</p><p>Redis： 一个开源的基于键值对和存储系统，具备高性能特征。支持主从复制（master-slave replication），并且具有非常快速的非阻塞首先同步（non-blockingfirst synchronization）、网络断开自动重连等功能。同时 Redis 还具有其他一些特征，其中包括简单的 check-and-set 机制、pub/sub 和配置设置等，以便使得 Redis 能够表现得更像缓存（Cace）。绝大部分主流编程语言都有官方推荐的客户端。</p><p>MongoDB： 一个开源的 C++ 编写的面向集合且模式自由的文档性数据库，是 NoSQL 中功能最丰富、最像关系型数据库的产品。</p><p>核心优势：灵活文档模型 + 高可用复制集 + 可扩展分片集群；</p><p>功能特点：二级索引、地理位置索引、aggregate、map-reduce、OridFS 支持文件存储。</p><p>不足之处：不支持事务，仅支持简单 left join。</p><p>Spanner：Google 的可扩展的、多版本的、全球分布式的同步复制方式数据库。Spanner 是第一个支持全球规模的分布式数据、外部一致性分布式事务的分布式数据库。它是一个在遍布全球范围的数据中心内部通过多套 Paxos 状态机器共享数据的数据库。复制被用于全局可用性和地理位置；客户在副本之间自动切换。当数据量或者服务器数量发生变化时，Spanner 在机器之间自动共享数据，并且 Spanner 在机器之间自动迁移数据（甚至在数据中心之间），用以负载均衡和响应失败。Spanner 被设计为在几百万台机器之上横向扩展，这些扩展穿过了数百个数据中心和万亿行数据。功能很强大，可惜没有开源。</p><p>ElasticSearch： 一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 Restful Web 接口。ElasticSearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。</p><p>最终通过这些技术之间的互相相似度对比，并且我们设定了一些规则，例如开源协议的约束，这一点其实逐渐开始真正起到约束了，看看 FaceBook 针对 Reactor 的专利约束给大家造成的麻烦，你就懂了。最终，我选择了 Cassandra、MongoDB、Reddis、MySQL、HBase 等几款进入下一步深入调研。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>我们进行技术选型，有的团队会根据社交媒体上的讨论来决定选择哪种架构，有的团队会跟风走，哪个热门就选哪个，这些都不是正确的方式，我们应该按照方法论执行。此外，我们作为团队管理者，一边要督促自己不断学习新技术，自己能够上手使用，也要结合实际团队情况，规划新技术的预研、落地步骤，让团队成员既能享受到稳定技术的红利，也能不断地尝试新事物，让大家能够看到未来，不担心自己逐渐落后于行业的发展，更能提升对于公司的归属感。做到这些，真不容易，加油，诸位。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;做技术选型时，要注意些什么？&quot;&gt;&lt;a href=&quot;#做技术选型时，要注意些什么？&quot; class=&quot;headerlink&quot; title=&quot;做技术选型时，要注意些什么？&quot;&gt;&lt;/a&gt;做技术选型时，要注意些什么？&lt;/h3&gt;&lt;p&gt;对于技术选型，有些建议供你参考。此外，还有一个实践案例供你借鉴。&lt;/p&gt;
    
    </summary>
    
    
      <category term="综合技能" scheme="https://github.com/renhongl/tags/%E7%BB%BC%E5%90%88%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Redux</title>
    <link href="https://github.com/renhongl/2018/05/10/redux/"/>
    <id>https://github.com/renhongl/2018/05/10/redux/</id>
    <published>2018-05-10T13:16:52.000Z</published>
    <updated>2018-06-18T14:10:40.484Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redux是什么？"><a href="#Redux是什么？" class="headerlink" title="Redux是什么？"></a>Redux是什么？</h4><a id="more"></a><ul><li>在Flux基础上的改进框架。</li><li>单向数流。</li><li>唯一数据源。</li><li>保持状态只读。</li><li>数据改变只能通过纯函数完成。</li></ul><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Redux是什么？&quot;&gt;&lt;a href=&quot;#Redux是什么？&quot; class=&quot;headerlink&quot; title=&quot;Redux是什么？&quot;&gt;&lt;/a&gt;Redux是什么？&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Redux" scheme="https://github.com/renhongl/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Flux</title>
    <link href="https://github.com/renhongl/2018/05/10/flux/"/>
    <id>https://github.com/renhongl/2018/05/10/flux/</id>
    <published>2018-05-10T13:16:52.000Z</published>
    <updated>2018-06-18T13:59:07.988Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Flux是什么？"><a href="#Flux是什么？" class="headerlink" title="Flux是什么？"></a>Flux是什么？</h4><a id="more"></a><ul><li>一种架构思想。</li><li>专门解决软件的结构问题。</li></ul><h4 id="传统MVC"><a href="#传统MVC" class="headerlink" title="传统MVC"></a>传统MVC</h4><p><img src="https://res.infoq.com/news/2014/05/facebook-mvc-flux/en/resources/flux-react-mvc.png" alt=""></p><h4 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h4><p><img src="https://res.infoq.com/news/2014/05/facebook-mvc-flux/en/resources/flux-react.png" alt=""></p><p>由图可见，Flux是单向数据流动。</p><ol><li>用户访问View</li><li>View发出Action</li><li>派发器发出Action, 要去Store进行更新</li><li>Store更新数据, 提醒View需要更新页面</li><li>View更新页面</li></ol><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Flux将应用分成四个部分。</p><ul><li>View: 视图层</li><li>Action: 动作，视图层发出的消息，比如鼠标点击</li><li>Dispatcher: 派发器，用来接收Actions，执行回调函数</li><li>Store: 数据层，用来存放应用的状态，一旦发生改变，就提醒View更新页面</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Flux是什么？&quot;&gt;&lt;a href=&quot;#Flux是什么？&quot; class=&quot;headerlink&quot; title=&quot;Flux是什么？&quot;&gt;&lt;/a&gt;Flux是什么？&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Redux" scheme="https://github.com/renhongl/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>数组的扩展</title>
    <link href="https://github.com/renhongl/2017/07/18/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/renhongl/2017/07/18/数组的扩展/</id>
    <published>2017-07-18T13:16:52.000Z</published>
    <updated>2018-06-18T13:47:24.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><a id="more"></a><p>Array.from()方法用于将<strong>类似数组的对象</strong>和<strong>可遍历的对象</strong>转为真正的数组。</p><p><strong>而扩展运算符只能将部署了Iterator接口的对象（可遍历对象）转换成数组。</strong></p><p>可转换对象包括：</p><pre><code>1. 类数组对象DOM集合2. 类数组对象arguments3. 部署了Iterator接口的Set和Map</code></pre><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of()方法用于将一组值转换为数组。因为数组的构造函数Array()在传入一个或多个参数时，创建的行为有差异。</p><h2 id="find-方法和findIndex-方法"><a href="#find-方法和findIndex-方法" class="headerlink" title="find()方法和findIndex()方法"></a>find()方法和findIndex()方法</h2><p>用于找出第一个符合条件的数组成员，它的第一个参数是回调函数，可用于自定义查找方法。第二个参数可用于绑定this。它们都可以发现NaN，用于替代indexOf。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>);<span class="comment">//-1</span></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));<span class="comment">//0</span></span><br></pre></td></tr></table></figure><h2 id="keys-values-和entries-方法"><a href="#keys-values-和entries-方法" class="headerlink" title="keys(),values()和entries()方法"></a>keys(),values()和entries()方法</h2><p>用于返回遍历器对象，可以使用for…of循环遍历。默认调用values()方法返回遍历器对象。</p><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p>用于表示某个数组是否包含给定值，可用于代替indexOf(),在不需要回调函数增加查找条件时，用includes()代替findIndex()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Array-from&quot;&gt;&lt;a href=&quot;#Array-from&quot; class=&quot;headerlink&quot; title=&quot;Array.from()&quot;&gt;&lt;/a&gt;Array.from()&lt;/h2&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>数值的扩展</title>
    <link href="https://github.com/renhongl/2017/07/16/%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/renhongl/2017/07/16/数值的扩展/</id>
    <published>2017-07-16T13:16:52.000Z</published>
    <updated>2018-06-18T13:47:40.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用0b和0o表示二进制和八进制"><a href="#使用0b和0o表示二进制和八进制" class="headerlink" title="使用0b和0o表示二进制和八进制"></a>使用0b和0o表示二进制和八进制</h2><a id="more"></a><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111</span> === <span class="number">7</span>;</span><br><span class="line"><span class="number">0o10</span> === <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h2 id="Number新API"><a href="#Number新API" class="headerlink" title="Number新API"></a>Number新API</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite()<span class="comment">;</span></span><br><span class="line">Number.isNaN()<span class="comment">;</span></span><br><span class="line">Number.parseInt()<span class="comment">;</span></span><br><span class="line">Number.parseFloat()<span class="comment">;</span></span><br><span class="line">Number.isInteger()<span class="comment">;</span></span><br><span class="line">Number.isSafeInteget()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="Math扩展API"><a href="#Math扩展API" class="headerlink" title="Math扩展API"></a>Math扩展API</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(); <span class="comment">//去除一个数的小数部分，返回整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.sign(); <span class="comment">//整数返回1，负数返回-1,0返回0，-0返回-0，其他返回NaN</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(); <span class="comment">//计算立方根</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用0b和0o表示二进制和八进制&quot;&gt;&lt;a href=&quot;#使用0b和0o表示二进制和八进制&quot; class=&quot;headerlink&quot; title=&quot;使用0b和0o表示二进制和八进制&quot;&gt;&lt;/a&gt;使用0b和0o表示二进制和八进制&lt;/h2&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>变量的解构赋值</title>
    <link href="https://github.com/renhongl/2017/07/15/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://github.com/renhongl/2017/07/15/变量的解构赋值/</id>
    <published>2017-07-15T13:16:52.000Z</published>
    <updated>2018-06-18T13:48:01.867Z</updated>
    
    <content type="html"><![CDATA[<ol><li>基本用法： <code>let [a, b, c] = [1, 2, 3]</code></li><li>默认值：<code>let [ n = 1] = []</code></li><li>解构不成功，变量的值等于undefined</li></ol><a id="more"></a><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><ol><li>基本用法：<code>let {foo, bar} = {foo: &#39;aaa&#39;, bar: &#39;bbb&#39;}</code></li><li>默认值：<code>let {x = 3} = {x: undefined}</code></li><li>默认值生效的条件是对象的属性值严格等于undefined</li></ol><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><ol><li>基本用法：<code>cosnt [a, b, c, d, e] = &#39;hello&#39;</code> //a = ‘h’, b = ‘e’</li></ol><h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h2><ol><li><p>交换变量的值： </p>   <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span> = <span class="number">2</span>;</span><br><span class="line">[x, y ] = [y, x]</span><br></pre></td></tr></table></figure></li><li><p>从函数返回多个值：</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></li><li><p>定义函数参数：</p>   <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x, y, z])</span> <span class="comment">&#123; ... &#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">([1, 2, 3])</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(<span class="comment">&#123;x, y, z&#125;</span>)</span> <span class="comment">&#123; ... &#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="comment">&#123;z: 3, y: 2, x: 1&#125;</span>)</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>提取JSON数据：</p>   <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  <span class="keyword">status</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="keyword">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, <span class="keyword">status</span>, <span class="keyword">data</span>: <span class="keyword">number</span> &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>);</span><br><span class="line">// <span class="number">42</span>, <span class="string">"OK"</span>, [<span class="number">867</span>, <span class="number">5309</span>]</span><br></pre></td></tr></table></figure></li><li><p>遍历map结构：</p>   <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let [<span class="built_in">key</span>, value] of <span class="built_in">map</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">key</span> + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>   ​</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;基本用法： &lt;code&gt;let [a, b, c] = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认值：&lt;code&gt;let [ n = 1] = []&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解构不成功，变量的值等于undefined&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Symbol</title>
    <link href="https://github.com/renhongl/2017/07/14/Symbol/"/>
    <id>https://github.com/renhongl/2017/07/14/Symbol/</id>
    <published>2017-07-14T13:16:52.000Z</published>
    <updated>2018-06-18T13:48:17.112Z</updated>
    
    <content type="html"><![CDATA[<p>Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值。它是JavaScript语言的第七种数据类型:</p><a id="more"></a><p>null, undefined, String, Number, Boolean, Object, Symbol。</p><p>使用Symbol()函数生成，因为它是一种类似字符串的数据类型，所以不是通过new创建的对象实例。</p><ul><li><p>作为属性名，在混合两个对象时，属性值不会被覆盖，因为一个Symbol是唯一的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义属性名和使用属性名时，使用方括号的调用方式。</span></span><br><span class="line"><span class="keyword">let</span> myNameSymbol = Symbol();</span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [<span class="meta">myNameSymbol</span>]: <span class="string">'renhongl'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[myNameSymbol];<span class="comment">//renhongl</span></span><br></pre></td></tr></table></figure></li><li><p>定义常量，消灭模式字符串</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="function">function <span class="title">operator</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'add'</span>:<span class="comment">//魔术字符串</span></span><br><span class="line">    <span class="comment">//do add</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"> <span class="comment">/*---more code----*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span>(<span class="string">'add'</span>);<span class="comment">//魔术字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//not bad</span></span><br><span class="line"><span class="keyword">var</span> operatorType = &#123;</span><br><span class="line">  <span class="keyword">add</span>: <span class="string">'add'</span>,</span><br><span class="line">  update: <span class="string">'update'</span>,</span><br><span class="line">  <span class="keyword">remove</span>: <span class="string">'remove'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">function <span class="title">operator</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> operatorType.<span class="keyword">add</span>:<span class="comment">//魔术字符串</span></span><br><span class="line">    <span class="comment">//do add</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"> <span class="comment">/*---more code----*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span>(operatorType.<span class="keyword">add</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为我们不关心add之后是什么值，可以使用一些方式</span></span><br><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="keyword">var</span> operatorType = &#123;</span><br><span class="line">  <span class="keyword">add</span>: Symbol(),</span><br><span class="line">  update: Symbol(),</span><br><span class="line">  <span class="keyword">remove</span>: Symbol(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">function <span class="title">operator</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> operatorType.<span class="keyword">add</span>:<span class="comment">//魔术字符串</span></span><br><span class="line">    <span class="comment">//do add</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"> <span class="comment">/*---more code----*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span>(operatorType.<span class="keyword">add</span>);</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值。它是JavaScript语言的第七种数据类型:&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Set 和 Map</title>
    <link href="https://github.com/renhongl/2017/07/13/Set%E5%92%8CMap/"/>
    <id>https://github.com/renhongl/2017/07/13/Set和Map/</id>
    <published>2017-07-13T13:16:52.000Z</published>
    <updated>2018-06-18T13:48:35.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>类似于数组的数据结构，成员的值都是<strong>唯一</strong>的。</p><a id="more"></a><ol><li><p>基本写法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> =  <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure></li><li><p>数组去重</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line">a = [...new Set(a)];<span class="comment">//[1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>实例的属性和方法</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">new</span> <span class="title">Set</span>();</span></span><br><span class="line"><span class="function"><span class="title">a</span>.<span class="title">add</span>(<span class="number">1</span>).<span class="title">add</span>(<span class="number">3</span>).<span class="title">add</span>(<span class="number">10</span>);</span></span><br><span class="line"><span class="function"><span class="title">a</span>.<span class="title">size</span>;<span class="comment">//3</span></span></span><br><span class="line"><span class="function"><span class="title">a</span>.<span class="title">has</span>(<span class="number">10</span>);<span class="comment">//true</span></span></span><br><span class="line"><span class="function"><span class="title">a</span>.<span class="title">delete</span>(<span class="number">10</span>);</span></span><br><span class="line"><span class="function"><span class="title">a</span>.<span class="title">has</span>(<span class="number">10</span>);<span class="comment">//false</span></span></span><br><span class="line"><span class="function"><span class="title">a</span>.<span class="title">clear</span>();</span></span><br><span class="line"><span class="function"><span class="title">a</span>.<span class="title">size</span>;<span class="comment">//</span></span></span><br></pre></td></tr></table></figure></li><li><p>遍历操作</p><ul><li>keys(): 返回键名的遍历器</li><li>values(): 返回键值得遍历器</li><li>entries(): 返回键值对的遍历器</li><li>forEach(): 使用回调函数遍历每个成员</li></ul></li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>解决Object只能使用字符串当做键的问题。</p><p>如果需要键值对的数据结构，Map比Object更合适。</p><ol><li><p>基本写法</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let items</span> = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'lrh'</span>],</span><br><span class="line">  [<span class="string">'age'</span>, 18]</span><br><span class="line">];</span><br><span class="line"><span class="attribute">const map</span> = new Map(items);</span><br></pre></td></tr></table></figure></li><li><p>实例的属性和方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.<span class="built_in">size</span>;<span class="comment">//2</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'gender'</span>, <span class="string">'male'</span>).<span class="built_in">set</span>(<span class="string">'experience'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">'gender'</span>);<span class="comment">//male</span></span><br><span class="line"><span class="built_in">map</span>.has(<span class="string">'experience'</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">map</span>.delete(<span class="string">'age'</span>)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">size</span>;<span class="comment">//0</span></span><br></pre></td></tr></table></figure></li><li><p>遍历操作</p><ul><li><p>keys()</p></li><li><p>values()</p></li><li><p>entries() 默认的遍历器接口</p></li><li><p>forEach()</p><p>​</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Set&quot;&gt;&lt;a href=&quot;#Set&quot; class=&quot;headerlink&quot; title=&quot;Set&quot;&gt;&lt;/a&gt;Set&lt;/h2&gt;&lt;p&gt;类似于数组的数据结构，成员的值都是&lt;strong&gt;唯一&lt;/strong&gt;的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>async 和 await</title>
    <link href="https://github.com/renhongl/2017/07/12/async%E5%92%8Cawait/"/>
    <id>https://github.com/renhongl/2017/07/12/async和await/</id>
    <published>2017-07-12T13:16:52.000Z</published>
    <updated>2019-01-01T03:08:31.158Z</updated>
    
    <content type="html"><![CDATA[<ol><li>基本用法</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPersonInformation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before get'</span>);</span><br><span class="line">  <span class="keyword">await</span> getPerson().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">      obj = data;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'after get '</span> + obj.name + <span class="string">' information'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = &#123;</span><br><span class="line">          name: <span class="string">'lrh'</span>,</span><br><span class="line">          age: <span class="number">18</span></span><br><span class="line">    &#125;;</span><br><span class="line">      resolve(p)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPersonInformation();</span><br></pre></td></tr></table></figure><p>   ​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;基本用法&lt;/li&gt;
&lt;/ol&gt;
   &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Generator函数</title>
    <link href="https://github.com/renhongl/2017/07/10/Generator/"/>
    <id>https://github.com/renhongl/2017/07/10/Generator/</id>
    <published>2017-07-10T13:16:52.000Z</published>
    <updated>2018-06-18T13:49:01.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><a id="more"></a><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* helloWorldGenerator() &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hwg = helloWorldGenerator();</span><br><span class="line">hwg.<span class="keyword">next</span>();<span class="regexp">//</span>&#123;<span class="symbol">value:</span> <span class="string">'hello'</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">hwg.<span class="keyword">next</span>();<span class="regexp">//</span>&#123;<span class="symbol">value:</span> <span class="string">'world'</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">hwg.<span class="keyword">next</span>();<span class="regexp">//</span>&#123;<span class="symbol">value:</span> <span class="string">'ending'</span>,  <span class="symbol">done:</span> <span class="literal">true</span>&#125;</span><br><span class="line">hwg.nexe();<span class="regexp">//</span>&#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>对象的扩展</title>
    <link href="https://github.com/renhongl/2017/06/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/renhongl/2017/06/22/对象的扩展/</id>
    <published>2017-06-22T11:57:38.000Z</published>
    <updated>2018-03-10T03:58:33.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="属性，方法的简洁写法"><a href="#属性，方法的简洁写法" class="headerlink" title="属性，方法的简洁写法"></a>属性，方法的简洁写法</h3><ul><li>属性名为变量名，属性值为变量值。</li></ul><a id="more"></a>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'lrh'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于方法返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'lrh'</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;name, age&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法的简写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'lrh'</span>,</span><br><span class="line">    age,</span><br><span class="line">    getName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="属性名可以使用表达式"><a href="#属性名可以使用表达式" class="headerlink" title="属性名可以使用表达式"></a>属性名可以使用表达式</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5定义对象的属性</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">'lrh'</span>;</span><br><span class="line">person.[<span class="string">'a'</span> + <span class="string">'ge'</span>] = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES5使用字面量定义属性时，只有下面一种方式</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'lrh'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6可以使用表达式为对象字面量定义属性</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'lrh'</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'ge'</span>]: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用Object-is-方法比较两个值相等"><a href="#使用Object-is-方法比较两个值相等" class="headerlink" title="使用Object.is()方法比较两个值相等"></a>使用Object.is()方法比较两个值相等</h3><ul><li>相等运算符（==）会自动转换数据类型。</li><li>严格相等运算符（===）会导致NaN不等于NaN，+0等于-0。</li><li><p>Object.is()方法与严格相等基本一致，并弥补了以上两个不足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>;</span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span>;</span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>);</span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用Object-assign-方法浅拷贝对象"><a href="#使用Object-assign-方法浅拷贝对象" class="headerlink" title="使用Object.assign()方法浅拷贝对象"></a>使用Object.assign()方法浅拷贝对象</h3><ul><li><p>将源对象合并到目标对象</p></li><li><p>如果有同名属性，源对象的属性会覆盖掉目标对象的属性。</p></li><li><p>该方法是浅拷贝，即如果源对象的某个属性值是对象，那么目标对象拷贝的是这个对象的引用，源对象的任何变化，都会反映到目标对象上。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">target</span> = &#123;a: 1&#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123;b: 2&#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123;c: 3&#125;;</span><br><span class="line">Object.assign(<span class="keyword">target</span>, source1, source2);</span><br><span class="line"><span class="keyword">target</span>;<span class="comment">//&#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>常见用途</p><ol><li><p>为对象添加属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;name, age&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'lrh'</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure></li><li><p>为对象添加方法</p></li></ol></li></ul><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;name, age&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype, &#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'lrh'</span>, <span class="number">18</span>).getName();<span class="comment">//lrh</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p>克隆对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'lrh'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Object</span>.assign(&#123;&#125;, person);<span class="comment">//&#123; name: 'lrh', age: 18 &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(person, p);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p>合并对象</p><figure class="highlight plain"><figcaption><span>wiki</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const source1 = &#123;name: &apos;lrh&apos;&#125;;</span><br><span class="line">const source2 = &#123;age: 18&#125;;</span><br><span class="line">const p = Object.assign(&#123;&#125;, source1, source2);//&#123; name: &apos;lrh&apos;, age: 18 &#125;</span><br></pre></td></tr></table></figure></li><li><p>为属性指定默认值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">options</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  container:</span> <span class="string">'#wrap'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  draggable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">  resizable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">  blinkTime:</span> <span class="number">4000</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="string">class</span> <span class="string">Draggable&#123;</span></span><br><span class="line">  <span class="string">constructor(options)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">const</span> <span class="string">DEFAULT</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      container:</span> <span class="string">''</span><span class="string">,</span></span><br><span class="line"><span class="attr">      draggable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">      resizable:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">this.options</span> <span class="string">=</span> <span class="string">Object.assign(&#123;&#125;,</span> <span class="string">DEFAULT,</span> <span class="string">options);</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol><h3 id="遍历属性"><a href="#遍历属性" class="headerlink" title="遍历属性"></a>遍历属性</h3><ul><li><p>for…in遍历对象自身的和继承的可枚举属性，不包含Symbol属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;name, age&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.type = <span class="string">'Person'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'lrh'</span>, <span class="number">18</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br><span class="line"><span class="comment">//gender</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.hasOwnProperty(p)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br></pre></td></tr></table></figure></li><li><p>Object.keys(obj)返回一个数组，包含对象自身所有的可枚举属性，不包含继承的属性，不包含Symbol属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">type</span> = Symbol(<span class="string">'type'</span>);</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'lrh'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  [<span class="keyword">type</span>]: <span class="string">'Student'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(person);<span class="comment">//['name', 'age']</span></span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身所有的可枚举属性和不可枚举属性，不包含Symbol属性。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="symbol">Object</span>.getOwnPropertyNames(arr);//[<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'length'</span>]</span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertySymbols(obj)返回一个数组，包含所有Symbol属性。</p></li><li><p>Reflect.ownKeys(obj)返回一个数组，包含所有可枚举属性，不可枚举属性，Symbol属性。</p></li><li><p>ES2015新增遍历法：Object.keys()， ES2017新增遍历方法：Object.values(), Object.entries()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'lrh'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(person);<span class="comment">//[ 'name', 'age' ]</span></span><br><span class="line"><span class="built_in">Object</span>.values(person);<span class="comment">//[ 'lrh', 18 ]</span></span><br><span class="line"><span class="built_in">Object</span>.entries(person);<span class="comment">//[ [ 'name', 'lrh' ], [ 'age', 18 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现entries()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personEntries = entries(person);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> p <span class="keyword">of</span> personEntries) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[ 'name', 'lrh' ]</span></span><br><span class="line"><span class="comment">//[ 'age', 18 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有使用entries()方法，可以给Symbol.iterator配置默认的迭代器</span></span><br><span class="line"><span class="built_in">Object</span>.assign(person, &#123;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">yield</span> [key, <span class="keyword">this</span>[key]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entries <span class="keyword">of</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entries);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[ 'name', 'lrh' ]</span></span><br><span class="line"><span class="comment">//[ 'age', 18 ]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用扩展运算符"><a href="#使用扩展运算符" class="headerlink" title="使用扩展运算符"></a>使用扩展运算符</h3><ul><li><p>扩展运算符是用于操作数组的</p></li><li><p>ES2018将这个运算符引入到了对象中</p></li><li><p>用于取出参数对象的所有可遍历属性，拷贝到当前对象中，等同于使用Object.assign()。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: <span class="string">'lrh'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line">const p = &#123;...person, type: <span class="string">'student'</span>&#125;;</span><br><span class="line">p;//&#123; name: <span class="string">'lrh'</span>, age: <span class="number">18</span>, type: <span class="string">'student'</span> &#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象的扩展&quot;&gt;&lt;a href=&quot;#对象的扩展&quot; class=&quot;headerlink&quot; title=&quot;对象的扩展&quot;&gt;&lt;/a&gt;对象的扩展&lt;/h2&gt;&lt;h3 id=&quot;属性，方法的简洁写法&quot;&gt;&lt;a href=&quot;#属性，方法的简洁写法&quot; class=&quot;headerlink&quot; title=&quot;属性，方法的简洁写法&quot;&gt;&lt;/a&gt;属性，方法的简洁写法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;属性名为变量名，属性值为变量值。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://github.com/renhongl/2017/06/20/Promise/"/>
    <id>https://github.com/renhongl/2017/06/20/Promise/</id>
    <published>2017-06-20T12:07:38.000Z</published>
    <updated>2018-03-10T03:58:55.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise是异步编程的一种解决方案，它是一个容器，里面保存着某个将来才会结束的事件。</p><p><strong>通过异步操作的结果，决定它是哪种状态。</strong></p><p><strong>pending —&gt; fulfilled   或者 pending —&gt; rejected</strong></p><a id="more"></a><ul><li><p>基本使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getData = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data loaded'</span>);</span><br><span class="line">        resolve(<span class="string">'get '</span> + url + <span class="string">' data successfully'</span>);</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(<span class="string">'test.json'</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>异步加载图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadImage = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">      img.onerror = reject;</span><br><span class="line">      img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">'img loaded'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">      img.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imgURL = <span class="string">'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=628594730,4098634647&amp;fm=27&amp;gp=0.jpg'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'loading...'</span>;</span><br><span class="line">loadImage(imgURL).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  img.style.width = <span class="string">'100px'</span>;</span><br><span class="line">  img.style.height = <span class="string">'100px'</span>;</span><br><span class="line">  img.src = imgURL;</span><br><span class="line">  <span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(img);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Ajax请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getData = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    client.responseType = <span class="string">'json'</span>;</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.setRequestHeader(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">    client.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(<span class="string">'test.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>应总是使用第一个then获取resolve状态的结果，使用catch获取错误的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getData(<span class="string">'test.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Promise.all()用于将多个Promise实例，包装成一个新的Promise实例</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">const</span> p = Promise.all([<span class="built_in">p1</span>, <span class="built_in">p2</span>, <span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure><ol><li>p1, p2, p3的状态都变成fulfilled, p也会变成fulfilled，p1, p2, p3的返回值组成一个数组传递给p的回调函数。</li><li>p1, p2, p3中只要有一个被rejected，p的状态就变成rejected, 第一个被rejected的实例的返回值，会传递给p的回调函数。</li></ol></li><li><p>Promise.race()也是将多个Promise实例包装成一个新的Promise实例</p><ol><li>p1, p2, p3只要有一个先改变状态，p的状态就跟着改变。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h2&gt;&lt;p&gt;Promise是异步编程的一种解决方案，它是一个容器，里面保存着某个将来才会结束的事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过异步操作的结果，决定它是哪种状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pending —&amp;gt; fulfilled   或者 pending —&amp;gt; rejected&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>let和const</title>
    <link href="https://github.com/renhongl/2017/06/18/let%E5%92%8Cconst/"/>
    <id>https://github.com/renhongl/2017/06/18/let和const/</id>
    <published>2017-06-18T12:15:38.000Z</published>
    <updated>2019-01-01T02:15:35.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><a id="more"></a><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<br>在代码块内，使用let命令声明变量之前，该变量都是不可用的。</p><h2 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h2><p>不允许在相同作用域内，重复声明同一个变量。</p><h2 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><ul><li>第一种场景，内层变量可能会覆盖外层变量。</li><li><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>如果真的想将对象冻结，应该使用Object.freeze方法。</p><p>对象及其属性冻结：</p></li></ul><pre><code>var constantize = (obj) =&gt; {    Object.freeze(obj);    Object.keys(obj).forEach( (key, i) =&gt; {        if ( typeof obj[key] === &apos;object&apos; ) {        constantize( obj[key] );        }    });};</code></pre><h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2><ol><li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li><li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li><li>Node 里面，顶层对象是global，但其他环境都不支持。</li></ol><pre><code>// 方法一(typeof window !== &apos;undefined&apos;    ? window    : (typeof process === &apos;object&apos; &amp;&amp;        typeof require === &apos;function&apos; &amp;&amp;        typeof global === &apos;object&apos;)        ? global        : this);    // 方法二    var getGlobal = function () {    if (typeof self !== &apos;undefined&apos;) { return self; }    if (typeof window !== &apos;undefined&apos;) { return window; }    if (typeof global !== &apos;undefined&apos;) { return global; }    throw new Error(&apos;unable to locate global object&apos;);};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不存在变量提升&quot;&gt;&lt;a href=&quot;#不存在变量提升&quot; class=&quot;headerlink&quot; title=&quot;不存在变量提升&quot;&gt;&lt;/a&gt;不存在变量提升&lt;/h2&gt;&lt;p&gt;var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。&lt;/p&gt;
&lt;p&gt;为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Iterator和for...of</title>
    <link href="https://github.com/renhongl/2017/06/16/Iterator%E5%92%8Cfor...of/"/>
    <id>https://github.com/renhongl/2017/06/16/Iterator和for...of/</id>
    <published>2017-06-16T12:29:38.000Z</published>
    <updated>2018-03-10T04:00:35.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Iterator-和-for…of循环"><a href="#Iterator-和-for…of循环" class="headerlink" title="Iterator 和 for…of循环"></a>Iterator 和 for…of循环</h2><h3 id="Iterator（遍历器）"><a href="#Iterator（遍历器）" class="headerlink" title="Iterator（遍历器）"></a>Iterator（遍历器）</h3><p>为各种不同的数据结构提供统一的访问机制。</p><p>任何数据结构只要部署了Iterator接口，就可以完成遍历操作。</p><p>遍历操作：依次处理该数据结构的所有成员。</p><a id="more"></a><h3 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h3><ol><li><p>创建一个指针对象，指向当前数据结构的起始位置。</p></li><li><p>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p></li><li><p>第二次调用指针对象的next方法，可以将指针指向数据结构的第二个成员。</p></li><li><p>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p><p>​</p></li></ol><h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><p>使用for…of循环遍历某种数据结构时，该循环会自动寻找这种数据结构默认的遍历器接口。</p><p>默认的遍历器接口部署在数据结构的Symbol.iterator属性上。</p><p>即只要一个数据结构具有Symbol.iterator属性，就认为是可遍历的(iterable)。</p><p>Symbol.iterator属性是一个函数，执行这个函数会返回一个遍历器。</p><h3 id="原生具备Iterator接口的数据结构"><a href="#原生具备Iterator接口的数据结构" class="headerlink" title="原生具备Iterator接口的数据结构"></a>原生具备Iterator接口的数据结构</h3><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>arguments</li><li>NodeList</li></ul><h3 id="除了for…of，其他会调用默认遍历器接口的情况"><a href="#除了for…of，其他会调用默认遍历器接口的情况" class="headerlink" title="除了for…of，其他会调用默认遍历器接口的情况"></a>除了for…of，其他会调用默认遍历器接口的情况</h3><ol><li>结构赋值</li><li>扩展运算符</li><li>yield*</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()</li><li>Promise.all()</li><li>Promise.race()</li></ol><h3 id="Iterator接口最简单实现"><a href="#Iterator接口最简单实现" class="headerlink" title="Iterator接口最简单实现"></a>Iterator接口最简单实现</h3><p>为Symbol.iterator创建一个Generator函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Iterator-和-for…of循环&quot;&gt;&lt;a href=&quot;#Iterator-和-for…of循环&quot; class=&quot;headerlink&quot; title=&quot;Iterator 和 for…of循环&quot;&gt;&lt;/a&gt;Iterator 和 for…of循环&lt;/h2&gt;&lt;h3 id=&quot;Iterator（遍历器）&quot;&gt;&lt;a href=&quot;#Iterator（遍历器）&quot; class=&quot;headerlink&quot; title=&quot;Iterator（遍历器）&quot;&gt;&lt;/a&gt;Iterator（遍历器）&lt;/h3&gt;&lt;p&gt;为各种不同的数据结构提供统一的访问机制。&lt;/p&gt;
&lt;p&gt;任何数据结构只要部署了Iterator接口，就可以完成遍历操作。&lt;/p&gt;
&lt;p&gt;遍历操作：依次处理该数据结构的所有成员。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Class</title>
    <link href="https://github.com/renhongl/2017/06/14/Class/"/>
    <id>https://github.com/renhongl/2017/06/14/Class/</id>
    <published>2017-06-14T11:16:52.000Z</published>
    <updated>2018-03-10T04:03:12.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>Javascript没有类的概念，要生成一个实例对象，是通过构造函数。</p><a id="more"></a><h3 id="传统写法："><a href="#传统写法：" class="headerlink" title="传统写法："></a>传统写法：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.name + <span class="string">', '</span> + <span class="keyword">this</span>.age + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'lrh'</span>, <span class="number">18</span>);</span><br><span class="line">p.toString();<span class="comment">//"(lrh, 18)"</span></span><br><span class="line">p.getName();<span class="comment">//"lrh"</span></span><br></pre></td></tr></table></figure><h3 id="使用ES6的Class语法"><a href="#使用ES6的Class语法" class="headerlink" title="使用ES6的Class语法:"></a>使用ES6的Class语法:</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.name + <span class="string">', '</span> + <span class="keyword">this</span>.age + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Person(<span class="string">'lrh'</span>, <span class="number">19</span>);</span><br><span class="line">p.toString();<span class="comment">//"(lrh, 18)"</span></span><br><span class="line">p.getName();<span class="comment">//"lrh"</span></span><br></pre></td></tr></table></figure><h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法:"></a>私有方法:</h4><ol><li><p>使用<strong>下划线” _ “</strong>区别方法名，但是外部还是可以调用这个方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getInfor() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">', '</span> + <span class="keyword">this</span>._getAge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = new Person(<span class="string">'lrh'</span>, <span class="number">18</span>);</span><br><span class="line">p.getInfor();<span class="comment">//"lrh, 18"</span></span><br></pre></td></tr></table></figure></li><li><p>将私有方法移出类，因为在类中方法都是对外可见的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getInfor() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">', '</span> + getAge.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getAge() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Person(<span class="string">'lrh'</span>, <span class="number">19</span>);</span><br><span class="line">p.getInfor();</span><br><span class="line">p.getAge();<span class="comment">//TypeError: p.getAge is not a function</span></span><br></pre></td></tr></table></figure></li><li><p>利用Symbol的唯一性，设置私有变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getAge = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  [getAge]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getInfor() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">', '</span> + <span class="keyword">this</span>[getAge]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Person(<span class="string">'lrh'</span>, <span class="number">18</span>);</span><br><span class="line">p.getInfor();</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><ol><li><p>使用#表示，但是还只是提案，babel都不支持。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  #type = <span class="string">'Student'</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getInfor() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">', '</span> + <span class="keyword">this</span>.age + <span class="string">', '</span> + <span class="keyword">this</span>.#type; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Person(<span class="string">'lrh'</span>, <span class="number">18</span>);</span><br><span class="line">p.getInfor();</span><br></pre></td></tr></table></figure></li></ol><h4 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h4><ol><li><p>拦截了该属性的存取行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//getter，setter对应的属性应该是一个_开头的私有属性，只有使用getter，setter的方式可以读取和修改</span><br><span class="line">class Person&#123;</span><br><span class="line">  constructor(name, age, gender) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this._gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  get gender() &#123;</span><br><span class="line">    console.log(&apos;getter&apos;);</span><br><span class="line">    return this._gender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  set gender(value) &#123;</span><br><span class="line">    console.log(&apos;setter&apos;);</span><br><span class="line">    this._gender = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Person(&apos;lrh&apos;, 18, &apos;male&apos;);</span><br><span class="line">p.gender;</span><br><span class="line">p.gender = &apos;female&apos;;</span><br><span class="line">p.gender;</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ol><li><p>在方法前加上static关键字，this指向类而不是实例。只能通过类调用。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  static getRandom() &#123;</span></span><br><span class="line"><span class="comment">  return Math.random();</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constructor</span><span class="params">(<span class="keyword">name</span>, age)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    this.name = name;</span></span></span><br><span class="line"><span class="function"><span class="comment">    this.age = age;</span></span></span><br><span class="line"><span class="function"><span class="comment">  &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">getRandom</span><span class="params">()</span>;</span><span class="comment">//0.36116181991876695</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="静态属性与实例属性"><a href="#静态属性与实例属性" class="headerlink" title="静态属性与实例属性"></a>静态属性与实例属性</h4><ol><li><p>是ES7的提案，需要安装ES7的转码：<code>npm install --save-dev babel-preset-stage-2</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例属性</span></span><br><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">'Student'</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person();<span class="comment">//Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态属性</span></span><br><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">type</span> = <span class="string">'Student'</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Person.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person();<span class="comment">//Student</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlink&quot; title=&quot;Class&quot;&gt;&lt;/a&gt;Class&lt;/h2&gt;&lt;p&gt;Javascript没有类的概念，要生成一个实例对象，是通过构造函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>rest参数和扩展运算符</title>
    <link href="https://github.com/renhongl/2017/06/12/rest%E5%8F%82%E6%95%B0%E5%92%8C%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://github.com/renhongl/2017/06/12/rest参数和扩展运算符/</id>
    <published>2017-06-12T11:42:01.000Z</published>
    <updated>2018-03-10T03:50:37.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>用于获取函数的多余参数，这样就不用使用arguments对象了，该变量将多余的参数放入数组中。</p><p>语法：<code>...args</code></p><a id="more"></a><ul><li><p>利用rest参数，可以向函数传入任意数量的参数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">  let total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (let key of args) &#123;</span><br><span class="line">    total += key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>);<span class="comment">//16</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">1</span>);<span class="comment">//4</span></span><br></pre></td></tr></table></figure></li><li><p>使用rest参数代替arguments</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Array.prototype.slice.call(arguments).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">  args.sort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rest参数之后不能再有参数，即rest参数只能是最后一个参数</p></li></ul><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><ul><li><p>好比rest参数的逆运算，将一个数组转换为用逗号分隔的序列。语法：<code>...[arr]</code></p><p><strong>在圆括号中成为参数序列：（…[1, 2, 3, 4]）=&gt; (1, 2, 3, 4) </strong></p><p><strong>在方括号中成为新数组：[1, 2, …[3, 4, 5]] =&gt; [1, 2, 3, 4, 5]</strong></p></li><li><p>可以用来替代函数的apply方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5写法-----apply方法第一个参数是上下文，第二个参数是方法的参数列表，但是是装在同一个数组里面。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure></li><li><p>求数组最大值:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5写法</span></span><br><span class="line">Math.max.apply(null, [<span class="number">23</span>, <span class="number">12</span>, <span class="number">54</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line">Math.max((...[<span class="number">23</span>, <span class="number">12</span>, <span class="number">54</span>]));</span><br><span class="line"><span class="comment">//等同于求max方法的参数的最大值</span></span><br><span class="line">Math.max(<span class="number">23</span>, <span class="number">12</span>, <span class="number">54</span>)</span><br></pre></td></tr></table></figure></li><li><p>将一个数组的所有元素一次添加到另一个数组</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5写法</span></span><br><span class="line">var arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">var arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">Array.prototype.push.apply(arr1, ar2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6的写法----因为push可以接受若干参数一次添加进数组，如果传入的是一个数组，那么这个数组就被当做整体添加就一个元素了。</span></span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure></li><li><p>复制数组</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5写法----concat用于连接两个数组，然后返回一个新数组，那么这两个数组就不是指向同一个地址了。</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.<span class="built_in">concat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];<span class="comment">//创建了新数组，填入了a1的所有项</span></span><br></pre></td></tr></table></figure></li><li><p>合并数组</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more);</span><br><span class="line">var arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">var arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">var arr3 = [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more];</span><br><span class="line">[...arr1, ...arr2, ...arr3];</span><br></pre></td></tr></table></figure></li><li><p>将实现了Iterator接口的对象，转化为数组</p></li></ul>  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类数组对象</span></span><br><span class="line"><span class="keyword">let</span> nodeList = document.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">let</span> arr1 = [...nodeList];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">  <span class="string">'length'</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arrayLike];<span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line"><span class="comment">//arrayLike没有部署Iterator接口，所以不能使用扩展运算符，可以使用Array.from将其装换为数组</span></span><br></pre></td></tr></table></figure><ul><li><p>Map和Set也实现了Iterator接口</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let map = new <span class="symbol">Map</span>([</span><br><span class="line">  [<span class="number">0</span>, <span class="string">'a'</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'b'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'c'</span>]</span><br><span class="line">]);</span><br><span class="line">let arr1 = [...map.keys()];//[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">let arr2 = [...map.values()];//[a, b, c]</span><br><span class="line">let arr3 = [...map.entries()];//[[<span class="number">1</span>, <span class="string">'a'</span>], [<span class="number">2</span>, <span class="string">'b'</span>], [<span class="number">3</span>, <span class="string">'c'</span>]]</span><br></pre></td></tr></table></figure></li><li><p>Generator函数运行后，返回一个遍历器对象，因此也可以用扩展运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()]<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;rest参数&quot;&gt;&lt;a href=&quot;#rest参数&quot; class=&quot;headerlink&quot; title=&quot;rest参数&quot;&gt;&lt;/a&gt;rest参数&lt;/h2&gt;&lt;p&gt;用于获取函数的多余参数，这样就不用使用arguments对象了，该变量将多余的参数放入数组中。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;...args&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://github.com/renhongl/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="https://github.com/renhongl/2017/06/03/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/06/03/适配器模式/</id>
    <published>2017-06-03T13:54:32.000Z</published>
    <updated>2018-12-23T13:24:45.338Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式<br>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><a id="more"></a><p>面向对象例子：</p><pre><code>/*** 将方法getFullSingaporeCityData返回的数据适配到* getSingaporeCityData的格式*/class Adapter{    getSingaporeCityData() {        return {            shenggang: {                id: &apos;0001&apos;,                coordinate: [1.3312, 103.32423]            },            fenwei: {                id: &apos;0002&apos;,                coordinate: [1.3221, 103.1212]            },            angmokio: {                id: &apos;0003&apos;,                coordinate: [1.654, 103.32465423]            }        }    }    getFullSingaporeCityData() {        return [            {                name: &apos;shenggang&apos;,                id: &apos;0001&apos;,                coordinate: [1.3312, 103.32423],                peopleCount: 10000            },            {                name: &apos;fenwei&apos;,                id: &apos;0002&apos;,                coordinate: [1.3312, 103.32423],                peopleCount: 20000            },            {                name: &apos;angmokio&apos;,                id: &apos;0003&apos;,                coordinate: [1.3312, 103.32423],                peopleCount: 30000            }        ]    }    dataAdapter(fn) {        let ret = {};        let list = fn();        list.forEach(function(v, k) {            let {name, ...props} = v;            ret[name] = {...props};        });        return function() {            return ret;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;适配器模式&lt;br&gt;适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="https://github.com/renhongl/2017/05/26/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/26/状态模式/</id>
    <published>2017-05-26T13:54:32.000Z</published>
    <updated>2018-12-23T13:23:39.979Z</updated>
    
    <content type="html"><![CDATA[<p>状态模式<br>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p><a id="more"></a><p>面向对象例子：</p><pre><code>class BasicState{    constructor(control) {        this.control = control;    }    btnWasPressed(dom) {        throw new Error(&apos;Basic function must be rewrite&apos;);    }    stopWasPressed(dom) {        throw new Error(&apos;Basic function must be rewrite&apos;);    }}class StopState extends BasicState{    constructor(control) {        super(control);    }    btnWasPressed(dom) {        console.log(&apos;starting play&apos;);        dom.innerText = &apos;pause&apos;;        this.control.setState(this.control.playState);    }    stopWasPressed(dom) {        console.log(&apos;stoped&apos;);        dom.innerText = &apos;start&apos;;        this.control.setState(this.control.stopState);    }}class PlayState extends BasicState{    constructor(control) {        super(control);    }    btnWasPressed(dom) {        console.log(&apos;paused&apos;);        dom.innerText = &apos;start&apos;;        this.control.setState(this.control.pauseState);    }    stopWasPressed(dom) {        console.log(&apos;stoped&apos;);        dom.innerText = &apos;start&apos;;        this.control.setState(this.control.stopState);    }}class PauseState extends BasicState{    constructor(control) {        super(control);    }    btnWasPressed(dom) {        console.log(&apos;starting play&apos;);        dom.innerText = &apos;pause&apos;;        this.control.setState(this.control.playState);    }    stopWasPressed(dom) {        console.log(&apos;stoped&apos;);        dom.innerText = &apos;start&apos;;        this.control.setState(this.control.stopState);    }}export default class Control{    constructor() {        this.stopState = new StopState(this);        this.playState = new PlayState(this);        this.pauseState = new PauseState(this);        this.currentState = this.stopState;    }    setState(state) {        this.currentState = state;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;状态模式&lt;br&gt;在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="https://github.com/renhongl/2017/05/25/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/25/装饰者模式/</id>
    <published>2017-05-25T13:54:32.000Z</published>
    <updated>2018-12-23T13:22:41.717Z</updated>
    
    <content type="html"><![CDATA[<p>装饰者模式</p><a id="more"></a><p>例子：</p><pre><code>//Example 1Function.prototype.before = function(beforeFn) {    let self = this;    return function() {        beforeFn.apply(this, arguments);        self.apply(this, arguments);    }}Function.prototype.after = function(afterFn) {    let self = this;    return function() {        self.apply(this, arguments);        afterFn.apply(this, arguments);    }}//Example 2let a = function() {    alert(1);}let _a = a;a = function() {    _a();    alert(2);}//Example 3window.onload = function() {    alert(1);}let onload = window.onload;window.onload = function() {    onload();    alert(2);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰者模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="https://github.com/renhongl/2017/05/22/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/22/中介者模式/</id>
    <published>2017-05-22T13:54:32.000Z</published>
    <updated>2018-12-23T13:21:31.421Z</updated>
    
    <content type="html"><![CDATA[<p>中介者模式<br>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。<br><a id="more"></a></p><p>例子：</p><pre><code>class Player{    constructor(name, teamColor, playerDirector) {        this.name = name;        this.teamColor = teamColor;        this.status = &apos;live&apos;;        this.playerDirector = playerDirector;        this.add();    }    win() {        console.log(&apos;for self win action: &apos; + this.name);    }    lose() {        console.log(&apos;for self lose action: &apos; + this.name);    }    add() {        console.log(&apos;for self add action: &apos; + this.name);        this.playerDirector.recieveMessage(&apos;add&apos;, this);    }    remove() {        console.log(&apos;for self remove action: &apos; + this.name);        this.playerDirector.recieveMessage(&apos;remove&apos;, this);    }    die() {        console.log(&apos;for self die action: &apos; + this.name);        this.playerDirector.recieveMessage(&apos;die&apos;, this);    }    getMessage(message) {        console.log(`${this.name} recieved message: ${message}`);    }}export class PlayerMediator{    constructor() {        this.players = {};    }    recieveMessage(type, player) {        this[type](player);    }    add(player) {        this.players[player.teamColor] = this.players[player.teamColor] || [];        this.players[player.teamColor].push(player);        this.getAllPlayerExceptThis(player).forEach((p) =&gt; {            p.getMessage(`player ${player.name} added.`);        });    }    remove(player) {        let index = this.players[player.teamColor].indexOf(player);        this.players[player.teamColor][index].status = &apos;disconnect&apos;;        this.getAllPlayerExceptThis(player).forEach((p) =&gt; {            p.getMessage(`player ${player.name} disconnected.`);        });        if (this.verifyOver(player.teamColor)) {            this.gameOver(player.teamColor)        }    }    die(player) {        let index = this.players[player.teamColor].indexOf(player);        this.players[player.teamColor][index].status = &apos;die&apos;;        this.getAllPlayerExceptThis(player).forEach((p) =&gt; {            p.getMessage(`player ${player.name} dead.`);        });        if (this.verifyOver(player.teamColor)) {            this.gameOver(player.teamColor)        }    }    getAllPlayerExceptThis(player) {        let ret = [];        for (let t of Object.keys(this.players)) {            for (let p of this.players[t]) {                if (player !== p) {                    ret.push(p);                }            }        }        return ret;    }    verifyOver(teamColor) {        for (let player of this.players[teamColor]) {            if (player.status === &apos;live&apos;) {                return false;            }        }        return true    }    gameOver(teamColor) {        for (let t of Object.keys(this.players)) {            for (let player of this.players[t]) {                if (teamColor === player.teamColor) {                    player.lose();                } else {                    player.win();                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中介者模式&lt;br&gt;中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="https://github.com/renhongl/2017/05/21/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/21/职责链模式/</id>
    <published>2017-05-21T13:54:32.000Z</published>
    <updated>2018-12-23T13:32:15.907Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象例子：</p><a id="more"></a><pre><code>export class Vip5{    constructor() {        this.level = 5;    }    getDiscount(pay, level) {        if (level === this.level) {            console.log(pay * 0.5);        } else {            this.nextChain.getDiscount(pay, level);        }    }    setNextChain(obj) {        this.nextChain = obj;    }}export class Vip3{    constructor() {        this.level = 3;    }    getDiscount(pay, level) {        if (level === this.level) {            console.log(pay * 0.7);        } else {            this.nextChain.getDiscount(pay, level);        }    }    setNextChain(obj) {        this.nextChain = obj;    }}export class Vip1{    constructor() {        this.level = 1;    }    getDiscount(pay, level) {        if (level === this.level) {            console.log(pay * 0.9);        } else {            this.nextChain.getDiscount(pay, level);        }    }    setNextChain(obj) {        this.nextChain = obj;    }}</code></pre><p>函数式例子：</p><pre><code>(function () {    var order = function (orderType, pay, stock) {        if (orderType === 1) {            if (pay === true) {                console.log(&apos;500元定金预购，得到100优惠券&apos;);            } else {                if (stock &gt; 0) {                    console.log(&apos;普通购买&apos;);                } else {                    console.log(&apos;手机库存不足&apos;);                }            }        } else if (ordertype === 2) {            if (pay === true) {                console.log(&apos;200元定金预购，得到50元优惠券&apos;);            } else {                if (stock &gt; 0) {                    console.log(&apos;普通购买&apos;);                } else {                    console.log(&apos;手机库存不足&apos;);                }            }        } else if (orderType === 3) {            if (stock &gt; 0) {                console.log(&apos;普通购买&apos;);            } else {                console.log(&apos;手机库存不足&apos;);            }        }    }    var Chain = function (fn) {        this.fn = fn;        this.successor = null;    };    Chain.prototype.setNextSuccessor = function (successor) {        this.successor = successor;    };    Chain.prototype.passRequest = function () {        var ret = this.fn.apply(this, arguments);        if (ret === &apos;nextSuccessor&apos;) {            return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments);        }    };    var order500 = function (orderType, pay, stock) {        if (orderType === 1 &amp;&amp; pay === true) {            console.log(&apos;500元定金预购，得到100元优惠券&apos;);        } else {            return &apos;nextSuccessor&apos;;        }    };    var order200 = function (orderType, pay, stock) {        if (orderType === 2 &amp;&amp; pay === true) {            console.log(&apos;200元定金预购，得到50元优惠券&apos;);        } else {            return &apos;nextSuccessor&apos;;        }    };    var orderNormal = function (orderType, pay, stock) {        if (stock &gt; 0) {            console.log(&apos;普通购买，无优惠券&apos;);        } else {            console.log(&apos;手机库存不足&apos;);        }    };    var init = function () {        order(1, true, 500);        var chainOrder500 = new Chain(order500);        var chainOrder200 = new Chain(order200);        var chainOrderNomal = new Chain(orderNormal);        chainOrder500.setNextSuccessor(chainOrder200);        chainOrder200.setNextSuccessor(chainOrderNomal);        chainOrder500.passRequest(1, false, 100);    };    init();})();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象例子：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="https://github.com/renhongl/2017/05/19/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/19/享元模式/</id>
    <published>2017-05-19T13:54:32.000Z</published>
    <updated>2018-12-23T13:19:09.042Z</updated>
    
    <content type="html"><![CDATA[<p>享元模式<br>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><a id="more"></a><p>面向对象例子：</p><pre><code>class Flyweight{    constructor() {        this.divPool = [];    }    createDiv(text, parent) {        if (this.divPool.length &gt; 0) {            console.log(`get from pool, pool count:${this.divPool.length}`);            let div = this.divPool.shift();            div.innerText = text;            parent.appendChild(div);            return div;        } else {            console.log(`create a new div, because pool count:${this.divPool.length}`);            let div = document.createElement(&apos;div&apos;);            div.innerText = text;            parent.appendChild(div);            return div;        }    }    removeDiv(node, parent) {        parent.removeChild(node);        this.recover(node);        console.log(`when ui remove div, restore this div, now pool has: ${this.divPool.length}`);    }    recover(node) {        this.divPool.push(node);    }}</code></pre><p>函数式例子：</p><pre><code>(function () {    var circleFactory = (function () {        var circlePool = [];        var parent = document.querySelector(&apos;.flyweight-body&apos;);        return {            create: function () {                if (circlePool.length !== 0) {                    return circlePool.shift();                } else {                    var div = document.createElement(&apos;div&apos;);                    div.setAttribute(&apos;class&apos;, &apos;flyweight-child&apos;);                    parent.appendChild(div);                    return div;                }            },            recover: function (dom) {                return circlePool.push(dom);            },            remove: function (oldPool) {                for (var i = 0; i &lt; oldPool.length; i++) {                    parent.removeChild(oldPool[i]);                }            }        }    })();    var renderCircle = (function () {        var circlePool = [];        return function (number) {            console.log(&apos;length: &apos; + circlePool.length);            for (var j = 0; j &lt; number.length; j++) {                circleFactory.recover(circlePool.pop());                circlePool.length = circlePool.length - 1;            }            console.log(&apos;length: &apos; + circlePool.length);            circleFactory.remove(circlePool);            circlePool = [];            for (var i = 0; i &lt; number; i++) {                var circle = circleFactory.create();                circle.style.left = Math.random() * 700 + &apos;px&apos;;                circle.style.top = Math.random() * 400 + &apos;px&apos;;                circlePool.push(circle);            }        }    })();    var init = function () {        Event.listen(&apos;draw-circle&apos;, function (args) {            var number = Number(args.number);            console.log(number);            renderCircle(number);        });    };    init();})();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;享元模式&lt;br&gt;享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;
&lt;p&gt;享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="https://github.com/renhongl/2017/05/17/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/17/模板方法模式/</id>
    <published>2017-05-17T13:54:32.000Z</published>
    <updated>2018-12-23T13:17:49.486Z</updated>
    
    <content type="html"><![CDATA[<p>模板方法模式<br>假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬到另外一个单一的地方，模板方法就是为解决这个问题而生的。</p><p>在模板方法中，可以使用钩子方法来隔离变化。我们在父类种容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要挂钩，这由子类自行决定。</p><p>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法中，而子类的方法具体怎么实现则是可变的，把这部分变化的逻辑封装到子类中。</p><a id="more"></a><p>面向对象例子：</p><pre><code>export class RenderDom{    constructor() {    }    createDom() {        throw new Error(&apos;Must need implement createDom function&apos;);    }    configStyle() {        throw new Error(&apos;Must need implement configStyle function&apos;);    }    appendToParent() {        throw new Error(&apos;Must need implement appendToParent function&apos;);    }}export class RenderDiv extends RenderDom {    constructor() {        super();    }    createDom() {        console.log(&apos;div created&apos;);    }}</code></pre><p>函数式例子：</p><pre><code>export const renderDom = function(obj) {    let createDom = obj.createDom || function() {        throw new Error(&apos;Must need implement createDom function&apos;);    }    let configStyle = obj.configStyle || function() {        throw new Error(&apos;Must need implement configStyle function&apos;);    }    let appendToParent = obj.appendToParent || function() {        throw new Error(&apos;Must need implement appendToParent function&apos;);    }    let F = function() {};    F.prototype.createDom = createDom;    F.prototype.configStyle = configStyle;    F.prototype.appendToParent = appendToParent;    return F;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模板方法模式&lt;br&gt;假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬到另外一个单一的地方，模板方法就是为解决这个问题而生的。&lt;/p&gt;
&lt;p&gt;在模板方法中，可以使用钩子方法来隔离变化。我们在父类种容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要挂钩，这由子类自行决定。&lt;/p&gt;
&lt;p&gt;模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法中，而子类的方法具体怎么实现则是可变的，把这部分变化的逻辑封装到子类中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="https://github.com/renhongl/2017/05/16/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/16/命令模式/</id>
    <published>2017-05-16T13:54:32.000Z</published>
    <updated>2018-12-23T13:16:35.539Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式<br>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。</p><p>调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p>命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p><a id="more"></a><p>面向对象例子：</p><pre><code>class RenderLogin{    constructor() {        this.login = document.createElement(&apos;div&apos;);            this.options = {            width: &apos;100px&apos;,            height: &apos;100px&apos;,            border: &apos;1px solid red&apos;        }    }    render(options) {        this.options = {...this.options, ...options};        for (let key of Object.keys(this.options)) {            this.login.style[key] = this.options[key];        }        document.body.appendChild(this.login);    }    remove() {        document.body.removeChild(this.login);    }}  class RenderLoginCommand{    constructor() {        this.renderLogin = new RenderLogin();    }              excute(reciever) {        this.renderLogin.render(reciever.options);    }    undo() {        this.renderLogin.remove();    }}export class LoginButton{    constructor() {        this.options = {            background: &apos;grey&apos;,            borderRadius: &apos;50%&apos;        }        this.renderLoginCommand = new RenderLoginCommand();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令模式&lt;br&gt;命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。&lt;/p&gt;
&lt;p&gt;调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。&lt;/p&gt;
&lt;p&gt;命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://github.com/renhongl/2017/05/13/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/13/观察者模式/</id>
    <published>2017-05-13T13:54:32.000Z</published>
    <updated>2018-12-23T13:15:30.647Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式<br>具体写法： 使用Map将话题和要执行的回调方法一一对应的存下来，即订阅。在发布这个话题时，使用发布的参数，执行这个话题的回调方法。</p><p>订阅前发布： 在发布某个话题时，如果这个话题尚未被订阅，那么将这个话题存储起来，等订阅之后，立即发布。那么，在写代码时，就不会发生发布在订阅之前，导致功能不能被触发的问题。</p><a id="more"></a><p>命名空间： 如果整个项目都使用了此模式，很容易在没有命名空间的情况下混淆话题。</p><p>面向对象例子：</p><pre><code>class Observer{    constructor() {        this.topicMapping = {};        this.publishStore = {};    }          subscribe(...args) {        let topic = args.shift();        let callback = args.shift();        if (!this.topicMapping[topic]) {            this.topicMapping[topic] = [];        }        this.topicMapping[topic].push(callback);        console.log(`subscribed topic ${topic}`);        //check if had subscribed        if (this.publishStore[topic]) {            console.log(`trigger topic ${topic} immediately`);            this.publish(topic, this.publishStore[topic]);            delete this.publishStore[topic];        }    }    publish(...args) {        let topic = args.shift();        if (this.topicMapping[topic]) {            this.topicMapping[topic].forEach((v, k) =&gt; {                v.apply(null, args);            });        } else {            console.log(`no topic: ${topic} has been subscribed, this publish will store here, after subscribe, will trigger`);            this.publishStore[topic] = args;        }    }    unsubscribe(...args) {        let topic = args.shift();        let callback = args.shift();        if (this.topicMapping[topic]) {            delete this.topicMapping[topic];            if (callback instanceof Function) {                callback(args);            }        } else {        console.log(`no topic ${topic} has been subscribe, so no need unsubscribe.`);        }    }}export default Observer;</code></pre><p>函数式例子：</p><pre><code>(function () {    window.Event = (function () {        var clientList = {},            offline = {},            listen,            trigger,            remove;        listen = function (key, fn) {            if (!clientList[key]) {                clientList[key] = [];            }            clientList[key].push(fn);            if (offline[key]) {                fn.apply(this, offline[key].shift());            }        };        trigger = function () {            var key = Array.prototype.shift.call(arguments),                fns = clientList[key];            if (!fns || fns.length === 0) {                if (!offline[key]) {                    offline[key] = [];                }                offline[key].push(arguments);                return false;            }            for (var i = 0, len = fns.length; i &lt; len; i++) {                fns[i].apply(this, arguments);            }        };        remove = function (key, fn) {            var fns = clientList[key];            if (!fns) {                return false;            }            if (!fn) {                fns.length = 0;            } else {                for (var i = 0, len = fns.length; i &lt; len; i++) {                    var _fn = fns[i];                    if (_fn === fn) {                        fns.splice(i, 1);                    }                }            }        };        return {            listen: listen,            trigger: trigger,            remove: remove,        }    })();    var init = function () {        Event.trigger(&apos;loaded&apos;, {            name: &apos;renhongl&apos;,            age: 18        });        setTimeout(function () {            Event.listen(&apos;loaded&apos;, function (args) {                console.log(args);            });        }, 2000);    };    init();})();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观察者模式&lt;br&gt;具体写法： 使用Map将话题和要执行的回调方法一一对应的存下来，即订阅。在发布这个话题时，使用发布的参数，执行这个话题的回调方法。&lt;/p&gt;
&lt;p&gt;订阅前发布： 在发布某个话题时，如果这个话题尚未被订阅，那么将这个话题存储起来，等订阅之后，立即发布。那么，在写代码时，就不会发生发布在订阅之前，导致功能不能被触发的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="https://github.com/renhongl/2017/05/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/12/迭代器模式/</id>
    <published>2017-05-12T13:54:32.000Z</published>
    <updated>2018-12-23T13:15:09.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p><p>内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。</p><p>外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。</p><p>中止迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h3&gt;&lt;p&gt;迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/p&gt;
&lt;p&gt;内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。&lt;/p&gt;
&lt;p&gt;外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。&lt;/p&gt;
&lt;p&gt;中止迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://github.com/renhongl/2017/05/06/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/06/代理模式/</id>
    <published>2017-05-06T13:54:32.000Z</published>
    <updated>2018-12-23T13:12:30.680Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式<br>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。</p><p>代理和本体接口保持一致，那么用户可以放心的请求代理，他只关心是否得到想要的结果；在任何使用本体的地方都可以替换成使用代理。</p><p>虚拟代理：例如实现图片预加载、合并http请求。</p><p>缓存代理：例如缓存ajax异步请求的数据，下次再打开同一页的时候，便可以直接使用之前的数据。</p><a id="more"></a><p>面向对象例子：</p><pre><code>export class LoadImage{    setUrl(url, target) {        target.src = url;    }}export class LoadImageProxy{    constructor() {        this.loadImage = new LoadImage();    }    setUrl(url, target) {        this.loadImage.setUrl(&apos;./image/p2.gif&apos;, target);        let img = new Image();        img.onload = () =&gt; {            setTimeout(() =&gt; {                this.loadImage.setUrl(url, target);            }, 2000);        }        img.src = url;    }}export class LoadData{    constructor() {        this.data = {            renhong: {                name: &apos;renhongl&apos;,                age: 18            },            mogu: {                name: &apos;mogu&apos;,                age: 19            }        };    }    load(name, callback) {        setTimeout(() =&gt; {            callback(this.data[name]);        }, 2000);    }}export class LoadDataProxy{    constructor() {        this.loadData = new LoadData();        this.cache = {};    }    load(name, callback) {        if (!this.cache[name]) {            this.loadData.load(name, (data) =&gt; {                this.cache[name] = data;                callback(data);            });        } else {            callback(this.cache[name]);        }    }}</code></pre><p>函数式例子：</p><pre><code>/** * 使用虚拟代理实现图片预加载 * 使用缓存代理实现ajax异步请求数据 */(function () {    var logoImg = (function () {        var logo = document.querySelector(&apos;.logo&apos;);        return {            setSrc: function (src) {                setTimeout(function () {                    logo.src = src;                });            }        }    })();    var proxyLogoImg = (function () {        var img = new Image();        img.onload = function () {            logoImg.setSrc(this.src);        }        return {            setSrc: function (src) {                logoImg.setSrc(&apos;./loading.png&apos;);                setTimeout(function () {                    img.src = src;                }, 3000);            }        }    })();    var fetchData = (function () {        return {            start: function (url, fn) {                fetch(url).then(function (response) {                    if (response.ok) {                        response.json().then(function (data) {                            setTimeout(function () {                                fn.call(this, data);                            }, 2000);                        });                    }                }).catch(function (err) {                    console.log(err);                });            }        }    })();    var proxyFetchData = (function () {        var cache = {};        return {            start: function (url, fn) {                var key = url.split(&apos;.&apos;)[0];                if (key in cache) {                    fn.call(this, cache[key]);                } else {                    fetchData.start(url, function (data) {                        cache[key] = data;                        fn.call(this, data);                    });                }            }        }    })();    var fetchDataAction = function () {        console.time(&apos;fetchData&apos;);        proxyFetchData.start(&apos;./1.json&apos;, function (data) {            console.log(data);            console.timeEnd(&apos;fetchData&apos;);        });    };    var init = function () {        proxyLogoImg.setSrc(&apos;./logo.png&apos;);        fetchDataAction();        setTimeout(function () {            fetchDataAction();        }, 5000);    };    init();})();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式&lt;br&gt;代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。&lt;/p&gt;
&lt;p&gt;代理和本体接口保持一致，那么用户可以放心的请求代理，他只关心是否得到想要的结果；在任何使用本体的地方都可以替换成使用代理。&lt;/p&gt;
&lt;p&gt;虚拟代理：例如实现图片预加载、合并http请求。&lt;/p&gt;
&lt;p&gt;缓存代理：例如缓存ajax异步请求的数据，下次再打开同一页的时候，便可以直接使用之前的数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>webpack全面理解</title>
    <link href="https://github.com/renhongl/2017/05/05/webpack%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3/"/>
    <id>https://github.com/renhongl/2017/05/05/webpack全面理解/</id>
    <published>2017-05-05T14:40:12.000Z</published>
    <updated>2018-03-10T03:45:12.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>Webpack是一个静态模块打包工具。将一切文件视为模块，可以像引入JavaScript文件一样，在代码中引入。</p><a id="more"></a><h2 id="Entry-Points"><a href="#Entry-Points" class="headerlink" title="Entry Points"></a>Entry Points</h2><p>入口点，就是打包的起始文件。有多种定义方式。</p><ol><li><p>单入口，使用字符串:</p><pre><code>const config = {    entry: &apos;./path/to/my/entry/file.js&apos;};module.exports = config;</code></pre></li><li><p>多入口，使用对象语法：</p><pre><code>const config = {    entry: {        app: &apos;./src/app.js&apos;,        vendors: &apos;./src/vendors.js&apos;    }};</code></pre></li></ol><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出，告诉webpack怎样将编译后的文件写入磁盘。输出只有一个。</p><ol><li><p>基本用法:</p><pre><code>const config = {    output: {        filename: &apos;bundle.js&apos;,        path: &apos;/home/proj/public/assets&apos;    }};module.exports = config;</code></pre></li><li><p>多入口点的用法:</p><pre><code>{    entry: {        app: &apos;./src/app.js&apos;,        search: &apos;./src/search.js&apos;    },    output: {        filename: &apos;[name].js&apos;,        path: __dirname + &apos;/dist&apos;    }}// writes to disk: ./dist/app.js, ./dist/search.js</code></pre></li></ol><h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>装载机，用于转换一个模块的源代码。类似于其他打包工具的任务功能。它允许你讲其他语言转换成JavaScript，或者像引入JavaScript文件一样引入图片，数据,CSS文件等。</p><ol><li><p>安装: <code>npm install --save-dev style-loader css-loader</code></p></li><li><p>配置:</p><pre><code> module: {    rules: [    {        test: /\.css$/,        use: [        { loader: &apos;style-loader&apos; },        {            loader: &apos;css-loader&apos;,            options: {            modules: true            }        }        ]    }    ]}</code></pre></li></ol><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>插件，是webpack的支柱，webpack本身就是创建在same plugin system之上的。它用来做loader不能做的事。</p><ol><li><p>插件的结构：是一个有apply属性的JavaScript对象。apply属性会被webpack编译器调用，用于整个编译周期。</p></li><li><p>基本用法：</p><pre><code>//installed via npmconst HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); const webpack = require(&apos;webpack&apos;); //to access built-in pluginsconst path = require(&apos;path&apos;);const config = {    entry: &apos;./path/to/my/entry/file.js&apos;,    output: {        filename: &apos;my-first-webpack.bundle.js&apos;,        path: path.resolve(__dirname, &apos;dist&apos;)    },    module: {        rules: [        {            test: /\.(js|jsx)$/,            use: &apos;babel-loader&apos;        }        ]    },    plugins: [        new webpack.optimize.UglifyJsPlugin(),        new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})    ]};module.exports = config;</code></pre></li><li><p>常用插件：</p><ul><li><p>html-webpack-plugin（输出控制的插件）</p><ol><li>安装: <code>npm install --save-dev html-webpack-plugin</code></li><li><p>配置: </p><pre><code>const path = require(&apos;path&apos;);+ const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = {    entry: {    app: &apos;./src/index.js&apos;,    print: &apos;./src/print.js&apos;    },+   plugins: [+     new HtmlWebpackPlugin({+       title: &apos;Output Management&apos;+     })+   ],    output: {    filename: &apos;[name].bundle.js&apos;,    path: path.resolve(__dirname, &apos;dist&apos;)    }};</code></pre></li><li>结论：使用该插件，每次创建会将index.html替换掉，自动引入多个入口的JavaScript文件。当我们在配置中新增、修改入口点时，就不用手动修改源代码。</li></ol></li><li><p>clean-webpack-plugin(清理/dist文件夹)</p><ol><li>安装: <code>npm install --save-dev clen-webpack-plugin</code></li><li><p>配置：</p><pre><code>const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);+ const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);module.exports = {    entry: {    app: &apos;./src/index.js&apos;,    print: &apos;./src/print.js&apos;    },    plugins: [+     new CleanWebpackPlugin([&apos;dist&apos;]),    new HtmlWebpackPlugin({        title: &apos;Output Management&apos;    })    ],    output: {    filename: &apos;[name].bundle.js&apos;,    path: path.resolve(__dirname, &apos;dist&apos;)    }};</code></pre></li><li>结论：创建之后，不会再有旧文件，只有刚生成的文件。</li></ol></li><li><p>uglifyjs-webpack-plugin(Tree shaking插件，用于去除为使用的代码，以及最小化代码)</p><ol><li>安装: <code>npm install --save-dev uglifyjs-webpack-plugin</code></li><li><p>配置:</p><pre><code>const path = require(&apos;path&apos;);+ const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);module.exports = {    entry: &apos;./src/index.js&apos;,    output: {        filename: &apos;bundle.js&apos;,        path: path.resolve(__dirname, &apos;dist&apos;)    - }    + },    + plugins: [    +   new UglifyJSPlugin()    + ]};</code></pre></li><li>结论：创建后，最小化了代码文件，并且没有将未使用的代码创建进来。就像一棵树，源代码像绿色的活着的叶子，死代码像秋天到了棕色的，死了的叶子，通过摇动这棵树，将死去的叶子摇下。</li></ol></li><li><p>CommonsChunkPlugin(代码分裂插件)</p><ol><li>安装: 属于webpack内建插件</li><li><p>配置: </p><pre><code>const path = require(&apos;path&apos;); + const webpack = require(&apos;webpack&apos;); const HTMLWebpackPlugin = require(&apos;html-webpack-plugin&apos;); module.exports = {     entry: {     index: &apos;./src/index.js&apos;,     another: &apos;./src/another-module.js&apos;     },     plugins: [     new HTMLWebpackPlugin({         title: &apos;Code Splitting&apos; -     }) +     }), +     new webpack.optimize.CommonsChunkPlugin({ +       name: &apos;common&apos; // Specify the common bundle&apos;s name. +     })     ],     output: {     filename: &apos;[name].bundle.js&apos;,     path: path.resolve(__dirname, &apos;dist&apos;)     } }; </code></pre></li><li>结论: 在没有使用该插件时，配置了多个入口，每个入口中都会存在共同使用的模块，代码就出现了重复。使用之后，共同使用的代码，会被创建在一个新的，单独的文件中。</li></ol></li></ul></li></ol><h2 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h2><p>开发时，我们需要做一些设置，使开发变得容易。</p><ol><li><p>Using source maps</p><ul><li>描述: 在使用webpack创建代码时，我们很难通过错误和警告去追踪源代码位置。</li><li><p>配置: </p><pre><code>module.exports = {    entry: {    app: &apos;./src/index.js&apos;,    print: &apos;./src/print.js&apos;    },+   devtool: &apos;inline-source-map&apos;,    plugins: [    new CleanWebpackPlugin([&apos;dist&apos;]),    new HtmlWebpackPlugin({        title: &apos;Development&apos;    })    ],    output: {    filename: &apos;[name].bundle.js&apos;,    path: path.resolve(__dirname, &apos;dist&apos;)    }};</code></pre></li></ul><ol start="3"><li>结论: 在devtool属性中配置 <code>inline-source-map</code>之后，我们将可以在控制台中找到出错的行数，并可以链接进源代码。</li></ol></li><li><p>Using Watch Mode</p><ul><li>描述: 如果每次修改源代码，我们都要去手动创建一次，这是一件很麻烦的事。</li><li><p>配置: </p><pre><code> &quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    +&quot;watch&quot;: &quot;webpack --watch&quot;,    &quot;build&quot;: &quot;webpack&quot;},</code></pre></li><li>结论: 添加watch参数，每次修改源代码之后，webpack会帮忙自动创建。</li></ul></li><li><p>Using webpack-dev-server</p><ul><li>描述: 提供一个简单的web服务器，并且能够自动刷新页面。</li><li>安装: <code>npm install --save-dev webpack-dev-server</code></li><li><p>配置: </p><pre><code>const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);module.exports = {    entry: {    app: &apos;./src/index.js&apos;,    print: &apos;./src/print.js&apos;    },    devtool: &apos;inline-source-map&apos;,+   devServer: {+     contentBase: &apos;./dist&apos;+   },    plugins: [    new CleanWebpackPlugin([&apos;dist&apos;]),    new HtmlWebpackPlugin({        title: &apos;Development&apos;    })    ],    output: {    filename: &apos;[name].bundle.js&apos;,    path: path.resolve(__dirname, &apos;dist&apos;)    }};</code></pre><ul><li>添加npm执行脚本: <code>&quot;start&quot;: &quot;webpack-dev-server --open&quot;</code></li></ul></li></ul></li></ol><h2 id="Production"><a href="#Production" class="headerlink" title="Production"></a>Production</h2><p>如何添加一个产品配置？我们需要将产品和开发时相同的配置提取出来，通过npm脚本传入不同的参数，在产品和开发时使用不同的webpack配置。</p><ol><li>安装: <code>npm install --save-dev webpack-merge</code></li><li><p>配置:</p><p> project: </p><pre><code>webpack-demo|- package.json- |- webpack.config.js+ |- webpack.common.js+ |- webpack.dev.js+ |- webpack.prod.js|- /dist|- /src    |- index.js    |- math.js|- /node_modules</code></pre><p> webpack.common.js</p><pre><code>+ const path = require(&apos;path&apos;);+ const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);+ const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);++ module.exports = {+   entry: {+     app: &apos;./src/index.js&apos;+   },+   plugins: [+     new CleanWebpackPlugin([&apos;dist&apos;]),+     new HtmlWebpackPlugin({+       title: &apos;Production&apos;+     })+   ],+   output: {+     filename: &apos;[name].bundle.js&apos;,+     path: path.resolve(__dirname, &apos;dist&apos;)+   }+ };</code></pre><p> webpack.dev.js</p><pre><code>+ const merge = require(&apos;webpack-merge&apos;);+ const common = require(&apos;./webpack.common.js&apos;);++ module.exports = merge(common, {+   devtool: &apos;inline-source-map&apos;,+   devServer: {+     contentBase: &apos;./dist&apos;+   }+ });</code></pre><p> webpack.prod.js</p><pre><code>+ const merge = require(&apos;webpack-merge&apos;);+ const webpack = require(&apos;webpack&apos;);+ const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);+ const common = require(&apos;./webpack.common.js&apos;);++ module.exports = merge(common, {+   devtool: &apos;source-map,+   plugins: [+     new UglifyJSPlugin({+        sourceMap: true+    }),+     new webpack.DefinePlugin({+        &apos;process.env.NODE_ENV&apos;: JSON.stringify    +     (&apos;produdction)+      })+   ]+ });</code></pre><p> NPM Scripts</p><pre><code>{    &quot;name&quot;: &quot;development&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;description&quot;: &quot;&quot;,    &quot;main&quot;: &quot;webpack.config.js&quot;,    &quot;scripts&quot;: {-     &quot;start&quot;: &quot;webpack-dev-server --open&quot;,+     &quot;start&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;,-     &quot;build&quot;: &quot;webpack&quot;+     &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;    },    &quot;keywords&quot;: [],    &quot;author&quot;: &quot;&quot;,    &quot;license&quot;: &quot;ISC&quot;,    &quot;devDependencies&quot;: {    &quot;clean-webpack-plugin&quot;: &quot;^0.1.17&quot;,    &quot;css-loader&quot;: &quot;^0.28.4&quot;,    &quot;csv-loader&quot;: &quot;^2.1.1&quot;,    &quot;express&quot;: &quot;^4.15.3&quot;,    &quot;file-loader&quot;: &quot;^0.11.2&quot;,    &quot;html-webpack-plugin&quot;: &quot;^2.29.0&quot;,    &quot;style-loader&quot;: &quot;^0.18.2&quot;,    &quot;webpack&quot;: &quot;^3.0.0&quot;,    &quot;webpack-dev-middleware&quot;: &quot;^1.12.0&quot;,    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;,    &quot;xml-loader&quot;: &quot;^1.2.1&quot;    }}</code></pre><p> Split CSS</p><ol><li>安装: <code>npm install --save-dev extract-text-webpack-plugin</code></li><li><p>配置:</p><pre><code>const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);    module.exports = {    module: {        rules: [        {            test: /\.css$/,            use: ExtractTextPlugin.extract({            fallback: &quot;style-loader&quot;,            use: &quot;css-loader&quot;            })        }        ]    },    plugins: [        new ExtractTextPlugin(&quot;styles.css&quot;),    ]}</code></pre></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h1&gt;&lt;p&gt;Webpack是一个静态模块打包工具。将一切文件视为模块，可以像引入JavaScript文件一样，在代码中引入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Webpack" scheme="https://github.com/renhongl/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://github.com/renhongl/2017/05/05/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/05/05/策略模式/</id>
    <published>2017-05-05T13:54:32.000Z</published>
    <updated>2018-12-23T13:10:06.299Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式<br>定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。</p><p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类context，context接受客户的请求，随后把请求委托给某一个策略类。</p><p>策略模式可以消除程序中大片的条件分支语句。</p><a id="more"></a><p>面向对象例子：</p><pre><code>class LevelA{    calculate(salary) {        return salary * 2;    }}class LevelB{    calculate(salary) {        return salary * 3;    }}class LevelC{    calculate(salary) {        return salary * 4;    }}export class GetBonus{    constructor() {        this.calculateMapping = {            A: new LevelA(),            B: new LevelB(),            C: new LevelC()        }    }    calculate(type, salary) {        return this.calculateMapping[type].calculate(salary);    }}</code></pre><p>函数式例子：</p><pre><code>/** * 使用策略模式实现表单验证 */(function () {    var strategies = {        isNotEmpty: function (value, errorMsg) {            if (value === &apos;&apos;) {                return errorMsg;            }        },        minLength: function (value, length, errorMsg) {            if (value.length &lt; length) {                return errorMsg;            }        },        isMobile: function (value, errorMsg) {            if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) {                return errorMsg;            }        },        isNumber: function (value, errorMsg) {            if (isNaN(Number(value))) {                return errorMsg;            }        }    };    var registerForm = document.querySelector(&apos;form&apos;);    var Validator = function () {        this.cache = [];    };    Validator.prototype.add = function (dom, rule, errorMsg) {        var arr = rule.split(&apos;:&apos;);        this.cache.push(function () {            var strategy = arr.shift();            arr.unshift(dom.value);            arr.push(errorMsg);            return strategies[strategy].apply(dom, arr)        });    };    Validator.prototype.start = function () {        for (var i = 0, len = this.cache.length; i &lt; len; i++) {            var msg = this.cache[i]();            if (msg) {                return msg;            }        }    };    var validataFunc = function () {        var validator = new Validator();        validator.add(registerForm.number, &apos;isNotEmpty&apos;, &apos;数量不能为空&apos;);        validator.add(registerForm.number, &apos;isNumber&apos;, &apos;请输入数字&apos;);        validator.add(registerForm.number, &apos;minLength:2&apos;, &apos;数量至少要2位字符&apos;);        var errorMsg = validator.start();        return errorMsg;    };    var init = function () {        document.querySelector(&apos;.submitBtn&apos;).onclick = function () {            var errorMsg = validataFunc();            if (errorMsg) {                alert(errorMsg);            } else {                Event.trigger(&apos;draw-circle&apos;, {number: registerForm.number.value});            }        };    };    init();})();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式&lt;br&gt;定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。&lt;/p&gt;
&lt;p&gt;一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类context，context接受客户的请求，随后把请求委托给某一个策略类。&lt;/p&gt;
&lt;p&gt;策略模式可以消除程序中大片的条件分支语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://github.com/renhongl/2017/04/29/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/04/29/单例模式/</id>
    <published>2017-04-29T13:54:32.000Z</published>
    <updated>2018-12-23T13:10:37.078Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式<br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>推荐使用惰性单例的方式创建，即在需要时才创建单例对象。并且需要把不变的部分隔离出来，把管理单例的逻辑和创建对象的逻辑分开，这两个方法可以独立变化而不互相影响。当它们连接在一起时，就完成了创建唯一实例对象的功能。</p><a id="more"></a><p>面向对象例子：</p><pre><code>//以下是基本实现方法，但是并没有实现：//并且需要把不变的部分隔离出来，把管理单例的逻辑和创建对象的逻辑分开//这两个方法可以独立变化而不互相影响。当它们连接在一起时，就完成了创建唯一实例对象的功能。&quot;//的功能。因为再加一个单例元素时，需要修改管理单利的类。SingletonDOM只是为CreateDOM而生的管理类。export class SingletonDOM{    constructor() {        this.createDOM = new CreateDOM;    }    create() {        if (!this.instance) {            return this.instance = this.createDOM.create();        }        return this.instance;    }}export class CreateDOM{    create(type) {        return document.createElement(type || &apos;div&apos;);    }}export class CreateButton{    create() {        return document.createElement(&apos;button&apos;);    }}//通用管理单例的类。export class GetSingleton{    constructor(ClassName) {        this.obj = new ClassName();    }    create() {        if (!this.instance) {            return this.instance = this.obj.create();        }        return this.instance;    }}</code></pre><p>函数式例子：</p><pre><code>/** * 使用单例模式实现一个登陆框。 * 包含一个智能命令模式，即可以直接实现请求的命令，不需要接收者的存在。 */(function () {    var createLoginDiv = function () {        var div;        div = document.createElement(&apos;div&apos;);        div.setAttribute(&apos;class&apos;, &apos;login&apos;);        document.querySelector(&apos;#app&apos;).appendChild(div);        var child = document.createElement(&apos;div&apos;);        child.setAttribute(&apos;class&apos;, &apos;login-child&apos;);        child.innerText = &apos;Login Dialog&apos;;        div.appendChild(child);        return div;    };    var createLoginButton = function () {        var button;        button = document.createElement(&apos;input&apos;);        button.type = &apos;button&apos;;        button.value = &apos;login&apos;;        button.setAttribute(&apos;class&apos;, &apos;loginBtn&apos;);        document.querySelector(&apos;#app&apos;).appendChild(button);        return button;    };    var getSingle = function (fn) {        var single;        return function () {            return single || (single = fn.apply(this, arguments));        }    };    var createSingleLogin = getSingle(createLoginDiv);    var createSingleLoginButton = getSingle(createLoginButton);    var openLoginDivCommand = (function () {        var loginDiv = createSingleLogin();        return {            excute: function () {                loginDiv.addEventListener(&apos;click&apos;, function (e) {                    if (e.target.getAttribute(&apos;class&apos;) !== &apos;login-child&apos;) {                        macroCommand.undo();                    }                });                loginDiv.style.display = &apos;flex&apos;;            },            undo: function () {                loginDiv.style.display = &apos;none&apos;;            }        }    })();    var clearInputCommand = (function () {        var input = document.querySelector(&apos;input&apos;);        var cache;        return {            excute: function () {                cache = input.value;                input.value = &apos;&apos;;            },            undo: function () {                input.value = cache;            }        }    })();    var macroCommand = (function () {        var commandList = [];        return {            add: function (command) {                commandList.push(command);            },            excute: function () {                for (var i = 0, len = commandList.length; i &lt; len; i++) {                    commandList[i].excute();                }            },            undo: function () {                for (var i = 0, len = commandList.length; i &lt; len; i++) {                    commandList[i].undo();                }            },            redo: function () {                macroCommand.excute();            }        }    })();    macroCommand.add(openLoginDivCommand);    macroCommand.add(clearInputCommand);    var init = function () {        var loginButton = createSingleLoginButton();        loginButton.addEventListener(&apos;click&apos;, function () {            macroCommand.excute();        });        setTimeout(function () {            macroCommand.redo();        }, 10000);    };    init();})();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式&lt;br&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;p&gt;推荐使用惰性单例的方式创建，即在需要时才创建单例对象。并且需要把不变的部分隔离出来，把管理单例的逻辑和创建对象的逻辑分开，这两个方法可以独立变化而不互相影响。当它们连接在一起时，就完成了创建唯一实例对象的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://github.com/renhongl/2017/04/27/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/renhongl/2017/04/27/原型模式/</id>
    <published>2017-04-27T03:54:32.000Z</published>
    <updated>2018-12-23T13:10:21.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>类并不是必须的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。</p><p>原型模式不但是一种设计模式，也被称为一种编程泛型。</p><p>ECMAScript5提供了Object.create方法，可以用来克隆对象。</p><p>但是create方法性能不如 var obj = {} 或者 var obj = new Object();</p><p>以上两种替代方式，内部都是克隆原型而得到对象。</p><a id="more"></a><p><strong>注：</strong> Javascript中的根对象是Object，所有的对象都从根对象克隆而来。</p><p>函数式例子：</p><pre><code>/** * 使用原型继承方式实现一个模板方法模式。 * 通过设置钩子方法，可以实现不同的子类使用不同的父类约束。 */(function () {    var Beverage = function () {};    Beverage.prototype.boilWater = function () {        console.log(&apos;把水煮沸。&apos;);    };    Beverage.prototype.brew = function () {        throw new Error(&apos;子类必须重写冲泡方法&apos;);    };    Beverage.prototype.poutInCup = function () {        throw new Error(&apos;子类必须重写把饮料倒入杯子方法&apos;);    };    Beverage.prototype.addCondiments = function () {        throw new Error(&apos;子类必须重写加调料方法&apos;);    };    Beverage.prototype.customerAddCondiments = function () {        return true;    }    Beverage.prototype.init = function () {        this.boilWater();        this.brew();        this.poutInCup();        if (this.customerAddCondiments()) {            this.addCondiments();        }    }    var Coffee = function () {};    Coffee.prototype = new Beverage();    Coffee.prototype.brew = function () {        console.log(&apos;冲泡咖啡&apos;);    };    Coffee.prototype.poutInCup = function () {        console.log(&apos;把咖啡倒进杯子&apos;);    };    Coffee.prototype.addCondiments = function () {        console.log(&apos;给咖啡加糖加牛奶&apos;);    };    Coffee.prototype.customerAddCondiments = function () {        return window.confirm(&apos;请问需要调料吗？&apos;);      }    var coffee = new Coffee();    coffee.init();})();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3&gt;&lt;p&gt;类并不是必须的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。&lt;/p&gt;
&lt;p&gt;原型模式不但是一种设计模式，也被称为一种编程泛型。&lt;/p&gt;
&lt;p&gt;ECMAScript5提供了Object.create方法，可以用来克隆对象。&lt;/p&gt;
&lt;p&gt;但是create方法性能不如 var obj = {} 或者 var obj = new Object();&lt;/p&gt;
&lt;p&gt;以上两种替代方式，内部都是克隆原型而得到对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript设计模式" scheme="https://github.com/renhongl/tags/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式</title>
    <link href="https://github.com/renhongl/2017/04/25/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E8%BF%B0/"/>
    <id>https://github.com/renhongl/2017/04/25/Javascript设计模式简述/</id>
    <published>2017-04-25T13:25:12.000Z</published>
    <updated>2019-01-01T03:37:07.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>全部代码：<a href="https://github.com/renhongl/front-end-demo/tree/master/demo-design-pattern">点击这里</a>。</p><p>设计模式的主题总是把不变的事物和变化的事物分离开来。</p><h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>如果它走起来像鸭子，叫起来也像鸭子，那么它就是鸭子。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><p>多态的思想是把“做什么”和“谁去做”分离开来。</p></li><li><p>多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。</p></li><li><p>多态的最根本好处在于，你不必再像的对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为，<br>你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。</p></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>封装的目的是将信息影藏。</li><li>一般而言，封装是指封装数据和封装实现。</li><li>更广义的封装，还包括封装类型和封装变化。</li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li><p>作为对象的方法调用。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);<span class="comment">//true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure></li><li><p>作为普通函数调用。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getName());<span class="comment">//global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">    name: <span class="string">'renhong'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = myObj.getName;<span class="comment">//普通函数调用</span></span><br><span class="line"><span class="built_in">console</span>.log(getName());<span class="comment">//global</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObj.getName());<span class="comment">//renhong, 对象的方法调用</span></span><br></pre></td></tr></table></figure></li><li><p>构造器调用。当用new运算符调用函数时，该函数总会返回一个对象，构造器里的this就指向这个对象。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'renhong'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//renhong</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果构造器显示返回一个对象，那么new之后返回的是这个对象，而不是this。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'renhong'</span>,</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'mogu'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//mogu</span></span><br></pre></td></tr></table></figure></li><li><p>call和apply调用。用于动态的改变传入函数的this。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'renhong'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">'mogu'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName());<span class="comment">//renhong</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName.call(obj2));<span class="comment">//mogu</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><ul><li>作用一模一样，区别只在于传入参数的形式不同。</li><li><p>apply接受两个参数，第一个参数指定函数体内部的this指向。第二个参数是一个数组或者类数组，这些元素全部作为参数传递给被调用的函数。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="function"><span class="keyword">func</span> = <span class="title">function</span><span class="params">(a, b, <span class="built_in">c</span>)</span></span> &#123;</span><br><span class="line">    console.log([a, b, <span class="built_in">c</span>]);<span class="comment">//[1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">apply</span><span class="params">(null, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>call 传入的参数是不固定的，第一个参数同样是代表函数体内的this指向，从第二个参数开始，每个参数一次被当做被调用的函数的参数传入。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="function"><span class="keyword">func</span> = <span class="title">function</span><span class="params">(a, b, <span class="built_in">c</span>)</span></span> &#123;</span><br><span class="line">    console.log([a, b, <span class="built_in">c</span>]);<span class="comment">//[1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">call</span><span class="params">(null, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>为什么要使用call和apply？</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//改变this指向</span></span><br><span class="line">  <span class="comment">//---------例子1</span></span><br><span class="line">  <span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">      name: <span class="string">'renhong'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">      name: <span class="string">'mogu'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line">  <span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName();<span class="comment">//window</span></span><br><span class="line">  getName.call(obj1);<span class="comment">//renhong</span></span><br><span class="line">  getName.call(obj2);<span class="comment">//mogu</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//---------例子2</span></span><br><span class="line">  <span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);<span class="comment">//div1</span></span><br><span class="line">      func();<span class="comment">//undefined，指向window</span></span><br><span class="line">      func.call(<span class="keyword">this</span>);<span class="comment">//div1，指向这个this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//---------例子3</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>() &#123;</span><br><span class="line">          <span class="keyword">let</span> type = <span class="string">'dialog'</span>;</span><br><span class="line">          <span class="keyword">this</span>.name = <span class="string">'controller'</span>;</span><br><span class="line">          renderControl();</span><br><span class="line">          handleEvents.call(<span class="keyword">this</span>);</span><br><span class="line">          renderDialog.call(<span class="keyword">this</span>, type);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">renderControl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//undefined，this指向window</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//controller</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">renderDialog</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(type);<span class="comment">//dialog</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//借用其他对象的方法</span></span><br><span class="line">  <span class="comment">//类数组对象arguments，没有push的方法，不能将元素push进去。我们首先调用数组的push方法，再手动将push方法内部的this指向改为arguments，就帮助arguments实现了push功能。</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);<span class="comment">//[1, 2, 3]</span></span><br><span class="line">  &#125;)(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄漏，所以要尽量减少闭包的使用。</p><p>局部变量本来应该在函数退出的时候被解除饮用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。</p><p>跟闭包和内存泄漏有关系的地方是，使用闭包的同时，比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候有可能造成内存泄漏。但这并非闭包问题，也并非Javascript问题。</p><p><strong>注：</strong> 当代码中需要全局变量时，可以使用闭包，将这个变量封装在一个函数中，那这个函数就封装了一个独立的功能，不再依赖外部的变量。</p><h2 id="函数柯里化（function-currying）"><a href="#函数柯里化（function-currying）" class="headerlink" title="函数柯里化（function currying）"></a>函数柯里化（function currying）</h2><p>currying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚传入的参数在函数形成的闭包中被保存起来。待到函数真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p><h2 id="uncurrying"><a href="#uncurrying" class="headerlink" title="uncurrying"></a>uncurrying</h2><p>当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。</p><p>同理，一个对象也未必只有使用它自身的方法。通过call和apply方法可以让对象去借用一个原本不属于它的方法。</p><h2 id="降频"><a href="#降频" class="headerlink" title="降频"></a>降频</h2><p>在一些情况下，函数的触发不是由用户直接控制的，在这些情景下，函数可能被非常频繁的调用，而造成大的性能问题。</p><p>例如在window的resize事件中，或者在div拖动事件中，会频繁的触发这些事件，并且DOM相关的操作非常消耗性能，这时浏览器可能会出现卡顿现象。</p><p>以上现象我们可以使用setTimeout来实现每隔固定时间来触发事件，如果过于频繁，将忽略那次的事件。</p><p>函数式例子：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resize = <span class="function"><span class="keyword">function</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer,</span><br><span class="line">        firstTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>,</span><br><span class="line">            self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(firstTime) &#123;</span><br><span class="line">            callback.apply(self, args);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            callback.apply(self, args);</span><br><span class="line">        &#125;, interval || <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onresize = resize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resized'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>面向对象例子：</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ReduceFrequency&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * input 输入时，不要每次去检查更改，在结束输入后200毫秒去检查</span></span><br><span class="line"><span class="comment">     * 这样可以减少监听频繁执行的事件带来的卡顿</span></span><br><span class="line"><span class="comment">     * @param &#123;DOM Object&#125; target </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    inputControl(target) &#123;</span><br><span class="line">        target.addEventListener(<span class="string">'input'</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            clearTimeout(<span class="keyword">this</span>.timer);</span><br><span class="line">            <span class="keyword">this</span>.timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(e.target.value);</span><br><span class="line">            &#125;, <span class="number">500</span>); </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鼠标每次移动时，并不是每次都去打印它的位置，而是将最近这个事件存起来，使用定时器每隔500毫秒</span></span><br><span class="line"><span class="comment">     * 打印一次最新的位置。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mouseMoveControl() &#123;</span><br><span class="line">        <span class="keyword">this</span>.inTimer = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.latestE = e;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.inTimer) &#123;</span><br><span class="line">                <span class="keyword">this</span>.inTimer = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.timer2 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = <span class="keyword">this</span>.latestE.pageX;</span><br><span class="line">                    <span class="keyword">let</span> y = <span class="keyword">this</span>.latestE.pageY;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now(), x, y);</span><br><span class="line">                    <span class="keyword">this</span>.inTimer = <span class="literal">false</span>;</span><br><span class="line">                &#125;, <span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一次生成1000个节点，改成每1秒生成100个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    renderDomControl() &#123;</span><br><span class="line">        <span class="keyword">let</span> total = <span class="number">1000</span>;</span><br><span class="line">        render();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">                dom.innerText = total;</span><br><span class="line">                <span class="built_in">document</span>.body.appendChild(dom);</span><br><span class="line">                total -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    render();</span><br><span class="line">                &#125;, <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;全部代码：&lt;a href=&quot;https://github.com/renhongl/front-end-demo/tree/master/d
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://github.com/renhongl/tags/Javascript/"/>
    
      <category term="设计模式" scheme="https://github.com/renhongl/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript标准参考教程重点</title>
    <link href="https://github.com/renhongl/2017/02/04/Javascript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E9%87%8D%E7%82%B9/"/>
    <id>https://github.com/renhongl/2017/02/04/Javascript标准参考教程重点/</id>
    <published>2017-02-04T14:00:06.000Z</published>
    <updated>2019-01-01T03:33:00.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记一些容易忘记的语法。</p><h2 id="标签-label-用法"><a href="#标签-label-用法" class="headerlink" title="标签(label)用法"></a>标签(label)用法</h2>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数组二中是否有数组一中的元素</span></span><br><span class="line"><span class="keyword">var</span> itHas = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">var</span> item = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'zhagnsanfeng'</span>, <span class="string">'sunwukong'</span>, <span class="string">'zhubajie'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'liangrenhong'</span>, <span class="string">'zhubajie'</span>, <span class="string">'xiaofeng'</span>];</span><br><span class="line">verify:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len1 = arr1.length; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, len2 = arr2.length; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] === arr2[j]) &#123;</span><br><span class="line">                itHas = <span class="literal">true</span>;</span><br><span class="line">                index = j;</span><br><span class="line">                item = arr2[j];</span><br><span class="line">                <span class="keyword">break</span> verify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">console</span>.log(itHas, index, item);</span><br></pre></td></tr></table></figure><p>当查找到一个符合的之后，就退出循环，这样可以节省时间。<br>如果在break之后不使用标签，只能跳出内层循环。</p><h2 id="for…in遍历对象属性"><a href="#for…in遍历对象属性" class="headerlink" title="for…in遍历对象属性"></a>for…in遍历对象属性</h2>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'lrh'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'18'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.gender = <span class="string">'boy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br><span class="line"><span class="comment">//gender</span></span><br></pre></td></tr></table></figure><p>使用for…in遍历会遍历出实例自身的属性以及继承的属性。<br>如果非要用for…in那就在遍历时加上hasOwnProperty方法判断：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'lrh'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'18'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.gender = <span class="string">'boy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="keyword">if</span>(person.hasOwnProperty(p)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br></pre></td></tr></table></figure><h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h2><p>用于检测对象是否包含某个属性</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'lrh'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> person;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>定义在一个函数内部的函数。</li><li>将函数内部与函数外部连接起来的一座桥梁。</li><li>可以读取函数内部的变量。</li><li><p>让函数内部变量一直保持在内存中。</p>  <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">count</span>(<span class="keyword">number</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span></span> () &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="keyword">number</span>++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = <span class="built_in">count</span>(<span class="number">5</span>);</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br></pre></td></tr></table></figure></li><li><p>封装对象的私有属性和私有方法。</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setGender</span><span class="params">(gender)</span> </span>&#123;</span><br><span class="line">        _gender = gender</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        getGender: getGender,</span><br><span class="line">        setGender: setGender</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lrh'</span>);</span><br><span class="line">p1.setGender(<span class="string">'boy'</span>);</span><br><span class="line">p1.getGender();<span class="comment">//boy</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>map方法对数组的所有成员一次调用一个函数，根据函数结果返回一个新数组。<br>map方法接受一个函数做为参数，调用时会将其传入三个参数，分辨是当前成员，当前位置，数组本身。<br>map方法还可以接受第二个参数，表示回调函数执行时this所指向的对象。</p><p>forEach方法与map方法类似，但是一般不返回值。如果需要有返回值，一般使用map方法。<br>forEach方法不能中断执行，总是会遍历完所有成员，这时可以使用for循环代替。</p><p>filter方法返回结构为true的成员。</p><p>some方法，只要有一个成员的返回值为true，那么整个some方法的返回值就是true。</p><p>every方法，每个数组成员的返回值是true，every方法才会返回true。</p><p>reduce方法，依次处理数组的每个成员，最终累计成一个值。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>substring方法用于从原字符串取出子字符串并返回，不改变原字符串。它与slice作用相同，但有一些奇怪的规则，因此不建议使用这个方法，优先使用slice。</p><p>如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。</p><p>如果参数是负数，substring方法会自动将负数转为0。</p><h2 id="对象的拷贝-浅拷贝"><a href="#对象的拷贝-浅拷贝" class="headerlink" title="对象的拷贝-浅拷贝"></a>对象的拷贝-浅拷贝</h2><p>确保拷贝后的对象，与原对象具有同样的prototype原型对象。<br>确保拷贝后的对象，与原对象具有同样的属性。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">orig</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(orig));</span><br><span class="line">    copyOwnPropertiesFrom(copy, orig);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnPropertiesFrom</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span></span><br><span class="line">        .getOwnPropertyNames(source)</span><br><span class="line">        .forEach(<span class="function"><span class="keyword">function</span>(<span class="params">propKey</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propKey);</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, propKey, desc);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;记一些容易忘记的语法。&lt;/p&gt;
&lt;h2 id=&quot;标签-label-用法&quot;&gt;&lt;a href=&quot;#标签-label-用法&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://github.com/renhongl/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>爱听播放器</title>
    <link href="https://github.com/renhongl/2017/01/21/%E7%88%B1%E5%90%AC%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>https://github.com/renhongl/2017/01/21/爱听播放器/</id>
    <published>2017-01-21T03:40:40.000Z</published>
    <updated>2019-01-01T03:30:07.934Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/aiting1.png" alt="AiTing"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个简洁、好看、功能丰富的歌曲，书籍播放器。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可以直接下载我打包好的windows版本： <a href="http://www.demodashi.com/demo/12542.html" target="_blank" rel="noopener">点击这里下载免安装版爱听播放器</a>, <a href="https://github.com/renhongl/AiTing">Github点赞</a>。</p><h2 id="自己打包"><a href="#自己打包" class="headerlink" title="自己打包"></a>自己打包</h2><ul><li><p>运行<code>npm install</code>安装依赖。</p></li><li><p>依赖中没有包含打包工具，可以使用<code>npm install electron-packager -g</code>，在全局安装打包模块。</p></li><li>使用终端进入根目录，运行<code>npm run package</code>。</li><li>接着在根目录会生成<strong>AiTing-win32-x64</strong>文件，进入此目录，双击<strong>AiTing.exe</strong>即可运行此软件。</li></ul><h2 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h2><p>本软件是在网页中抓的API，音乐播放抓的是酷狗的API，书籍播放抓的是懒人听书的API。主要抓了搜索功能和基本推荐功能。</p><h3 id="音乐播放"><a href="#音乐播放" class="headerlink" title="音乐播放"></a>音乐播放</h3><p><img src="/images/aiting3.png" alt="AiTing"></p><p>这是音乐主页，展示了推荐歌曲分类，以及热门歌手推荐。</p><p><img src="/images/aiting2.png" alt="AiTing"></p><p>这是音乐搜索结果界面。</p><p><img src="/images/aiting4.png" alt="AiTing"></p><p>这是歌词界面。</p><h3 id="书籍播放"><a href="#书籍播放" class="headerlink" title="书籍播放"></a>书籍播放</h3><p><img src="/images/aiting5.png" alt="AiTing"></p><p>这是书籍的推荐页面。</p><p><img src="/images/aiting6.png" alt="AiTing"></p><p>这是书籍搜索结果界面。</p><p><img src="/images/aiting7.png" alt="AiTing"></p><p>由于书籍章节的搜索很慢，所以使用分页显示的方式。</p><h2 id="使用技术"><a href="#使用技术" class="headerlink" title="使用技术"></a>使用技术</h2><p>Javascript, Electron, Webpack, React.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/aiting1.png&quot; alt=&quot;AiTing&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;一个简洁、好看、功能丰富的歌曲，书籍
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://github.com/renhongl/tags/Javascript/"/>
    
      <category term="分享" scheme="https://github.com/renhongl/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="React" scheme="https://github.com/renhongl/tags/React/"/>
    
      <category term="Electron" scheme="https://github.com/renhongl/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS刷票程序</title>
    <link href="https://github.com/renhongl/2017/01/08/NodeJS%E5%88%B7%E7%A5%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://github.com/renhongl/2017/01/08/NodeJS刷票程序/</id>
    <published>2017-01-08T09:07:46.000Z</published>
    <updated>2019-01-01T03:25:00.576Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/buyTicket.jpg" alt="buy_ticket"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是一个脚本程序，运行在NodeJS环境之上，功能类似360抢票王。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>假设已经安装了node环境，从github上clone下源代码（<a href="https://github.com/renhongl/Buy_Ticket">源码在这</a>）</p><p>运行<code>npm install</code>安装依赖</p><p>双击run.bat即可</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>控制台每隔30秒打印最新票量信息，如果没有票，显示 <strong>No data found</strong>，如果有，则一一列出来。根目录文件夹也会生成一个log.txt文件，方便查看之前刷票的结果。在有票的时候，还会通过短信告知用户，效果图在文章开始已经列出。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码主要是通过request模块从携程网的查询票量的API中获取数据，经过筛选数据后，将符合要求的数据发给用户。</p><h3 id="发送短信的代码："><a href="#发送短信的代码：" class="headerlink" title="发送短信的代码："></a>发送短信的代码：</h3>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> App = <span class="built_in">require</span>(<span class="string">'alidayu-node'</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> App(<span class="string">'App Key'</span>, <span class="string">'App Secret'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> message = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">       <span class="string">"name"</span>: <span class="string">"lrh"</span>,</span><br><span class="line">       <span class="string">"trainName"</span>: <span class="string">'D5154'</span>,</span><br><span class="line">       <span class="string">"number"</span>: <span class="string">'2'</span></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> smsOptions = &#123;</span><br><span class="line">       sms_free_sign_name: <span class="string">'提示信息'</span>,</span><br><span class="line">       sms_param: message,</span><br><span class="line">       rec_num: <span class="string">'81193903'</span>,</span><br><span class="line">       sms_template_code: <span class="string">'SMS_39010188'</span></span><br><span class="line">   &#125;;</span><br><span class="line">   app.smsSend(options);</span><br></pre></td></tr></table></figure><p>这是使用的阿里大于的API，在官网注册账号后，需要创建新应用获取<strong>App Key</strong>和 <strong>App Secret</strong>，接着需要为自己的短信申请签名和模板。申请成功后，就可以用上面的方式来发送短信了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/buyTicket.jpg&quot; alt=&quot;buy_ticket&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这是一个脚本程序，运行在
      
    
    </summary>
    
    
      <category term="分享" scheme="https://github.com/renhongl/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="Nodejs" scheme="https://github.com/renhongl/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB安装</title>
    <link href="https://github.com/renhongl/2017/01/05/MongoDB%E5%AE%89%E8%A3%85/"/>
    <id>https://github.com/renhongl/2017/01/05/MongoDB安装/</id>
    <published>2017-01-05T14:11:56.000Z</published>
    <updated>2019-01-01T03:23:14.080Z</updated>
    
    <content type="html"><![CDATA[<p>简介</p><p>记录一些和Mongo DB有关的笔记（部分修改自runoob）。</p><h2 id="安装Mongo后的基本配置"><a href="#安装Mongo后的基本配置" class="headerlink" title="安装Mongo后的基本配置"></a>安装Mongo后的基本配置</h2><p>MongoDB将数据目录存储在 db 目录下。但是这个数据目录不会主动创建，在安装完成后需要创建它。请注意，数据目录应该放在根目录下（(如： C:\ 或者 D:\ 等 )。<br>在本教程中，已经在C：盘 安装了 mongodb，现在创建一个data的目录然后在data目录里创建db目录。</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">c</span>:\&gt;cd c:\</span><br><span class="line"></span><br><span class="line"><span class="title">c</span>:\&gt;mkdir <span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span>:\&gt;cd <span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span>:\<span class="class"><span class="keyword">data</span>&gt;mkdir db</span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span>:\<span class="class"><span class="keyword">data</span>&gt;cd db</span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span>:\<span class="class"><span class="keyword">data</span>\db&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过window的资源管理器中创建这些目录，而不一定通过命令行。</p><p>为了从命令提示符下运行MongoDB服务器，必须从MongoDB目录的bin目录中执行mongod.exe文件。为了方便，可以将mongod.exe添加到环境变量中。</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod<span class="selector-class">.exe</span> --dbpath c:\data\db</span><br></pre></td></tr></table></figure><p>如果执行成功，会输出如下信息：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2015-09-25T15:54:09.212+0800 I CONTROL  Hotfix KB2731284 <span class="keyword">or</span> later update is <span class="keyword">not</span></span><br><span class="line">installed, will zero-out data files</span><br><span class="line">2015-09-25T15:54:09.229+0800 I JOURNAL  [initandlisten] journal <span class="attribute">dir</span>=c:\data\db\j</span><br><span class="line">ournal</span><br><span class="line">2015-09-25T15:54:09.237+0800 I JOURNAL  [initandlisten] recover : <span class="literal">no</span> journal fil</span><br><span class="line">es present, <span class="literal">no</span> recovery needed</span><br><span class="line">2015-09-25T15:54:09.290+0800 I JOURNAL  [durability] Durability thread started</span><br><span class="line">2015-09-25T15:54:09.294+0800 I CONTROL  [initandlisten] MongoDB starting : <span class="attribute">pid</span>=2</span><br><span class="line">488 <span class="attribute">port</span>=27017 <span class="attribute">dbpath</span>=c:\data\db 64-bit <span class="attribute">host</span>=WIN-1VONBJOCE88</span><br><span class="line">2015-09-25T15:54:09.296+0800 I CONTROL  [initandlisten] targetMinOS: Windows 7/W</span><br><span class="line">indows<span class="built_in"> Server </span>2008 R2</span><br><span class="line">2015-09-25T15:54:09.298+0800 I CONTROL  [initandlisten] db version v3.0.6</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="将MongoDB作为服务启动"><a href="#将MongoDB作为服务启动" class="headerlink" title="将MongoDB作为服务启动"></a>将MongoDB作为服务启动</h2><p>请注意，必须有<strong>管理权限</strong>才能运行下面的命令。执行以下命令将MongoDB服务器作为Windows服务运行：</p>  <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">mongod</span><span class="string">.</span><span class="comment">exe</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bind_ip</span> <span class="comment">127</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">logpath</span> <span class="comment">C:\data\dbConf\mongodb</span><span class="string">.</span><span class="comment">log</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">logappend</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">dbpath</span> </span><br><span class="line"><span class="comment">C:\data\db</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">27017</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">serviceName</span> <span class="comment">mongo</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">serviceDisplayName</span> <span class="comment">mongo</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">install</span></span><br></pre></td></tr></table></figure><p>参数说明：</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--bind_ip 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP</span></span><br><span class="line"><span class="comment">--logpath定MongoDB日志文件，注意是指定文件不是目录</span></span><br><span class="line"><span class="comment">--logappend使用追加的方式写日志</span></span><br><span class="line"><span class="comment">--dbpath指定数据库路径</span></span><br><span class="line"><span class="comment">--port指定服务端口号，默认端口27017</span></span><br><span class="line"><span class="comment">--serviceName指定服务名称</span></span><br><span class="line"><span class="comment">--serviceDisplayName指定服务名称，有多个mongodb服务时执行。</span></span><br><span class="line"><span class="comment">--install指定作为一个Windows服务安装。</span></span><br></pre></td></tr></table></figure><p>再次强调，必须使用通过管理员方式打开的控制台，才能成功。如果不知道怎么通过管理员身份打开控制台，请进入c:/Windows/System32/找到cmd.exe，右键点击使用管理员身份运行。</p><p>安装完之后，继续运行：</p>  <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> mongo (mongo是刚才的服务名称)</span><br></pre></td></tr></table></figure><p>如果出现类似<strong>启动服务成功</strong>的提示，那么就完成了；如果出现<strong>没有此服务</strong>的提示，那就是没有安装成功，需要检查以上步骤。</p><h2 id="MongoDB后台管理-Shell"><a href="#MongoDB后台管理-Shell" class="headerlink" title="MongoDB后台管理 Shell"></a>MongoDB后台管理 Shell</h2><p>安装完成后，想要测试数据库是否可以连接，可以使用MongoDB自带的js shell，打开一个cmd，输入<code>mongo</code>即可连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;记录一些和Mongo DB有关的笔记（部分修改自runoob）。&lt;/p&gt;
&lt;h2 id=&quot;安装Mongo后的基本配置&quot;&gt;&lt;a href=&quot;#安装Mongo后的基本配置&quot; class=&quot;headerlink&quot; title=&quot;安装Mongo后的基本配置&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Mongo" scheme="https://github.com/renhongl/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>Git使用SSH提交代码</title>
    <link href="https://github.com/renhongl/2016/12/14/Git%E4%BD%BF%E7%94%A8SSH%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/renhongl/2016/12/14/Git使用SSH提交代码/</id>
    <published>2016-12-14T13:28:09.000Z</published>
    <updated>2019-01-01T03:20:52.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果经常提交代码，每次都要输入密码就很麻烦，使用SSH连接后，就不用输入密码了。</p><ul><li>配置全局用户名和邮箱：<ul><li><code>git config --global user.name &quot;renhongl&quot;</code></li><li><code>git config --global user.email &quot;1075220132@qq.com&quot;</code></li></ul></li><li>先检查本地有没有ssh key设置，查看~/这个文件夹下有没有.ssh文件夹，有的话就删除掉。</li><li>在~路径下生成新的ssh key:<ul><li><code>ssh-keygen -t rsa -C &quot;1075220132@qq.com&quot;</code></li></ul></li><li>三次回车后就生成了ssh key，在~/.ssh/文件夹下面，复制id_rsa.pub这个文件里所有的内容，粘贴到GitHub网站settings/keys里面，保存。</li><li>测试ssh key是否配置成功：<ul><li><code>$ ssh -T git@github.com</code></li></ul></li><li>然后输入yes,如果出现 “Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.”就表示配置好了。</li><li>配置完成后，在Github上克隆项目时，使用SSH方式，远程地址就设置成SSH方式了，push的时候就不用输入密码了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;如果经常提交代码，每次都要输入密码就很麻烦，使用SSH连接后，就不用输入密码了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置全局用户名和邮箱：&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="Git" scheme="https://github.com/renhongl/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>实用工具推荐</title>
    <link href="https://github.com/renhongl/2016/12/07/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://github.com/renhongl/2016/12/07/实用工具推荐/</id>
    <published>2016-12-07T14:49:59.000Z</published>
    <updated>2019-01-01T03:19:54.556Z</updated>
    
    <content type="html"><![CDATA[<p>分享一些好用的Windows工具。<br><a id="more"></a></p><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><p>我用过notepad++, sublime, atom, vscode, 各有各的特点，但是我更喜欢用后两个，因为作为一个前端开发，更喜欢用Web技术开发的工具。而VS Code 性能更好一点，就选择了它，功能也很强大，可以安装各种插件，丰富主题和功能，本身内置了很多有用的功能，比如：调试工具，终端，Git等等。</p><p>很多工作区的设置还可以通过用户设置来重写配置，比如当我使用windows时，终端是cmd,命令特别不好用，就可以去首选项-用户设置中将终端路径改为git的bash，当然首先需要安装过git。改完之后，就可以在不用切换工具的情况下，使用bash。特别实用。</p><h2 id="Ngrok"><a href="#Ngrok" class="headerlink" title="Ngrok"></a>Ngrok</h2><p>这是内网穿透工具，比如在本地启动一个服务器 <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a> 使用ngrok可以将8080端口映射到外网，那么即使你没有外网ip地址，没有云服务器，也可以通过这种方式让别人访问到你的本地应用。</p><p>如果百度sunny ngrok，可以找到国内免费的ngrok工具，以前是全免费，后来有收费提速的选择。就是不是很稳定，据说是同行nat123总是攻击他们的服务器。</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>引用官网的话——Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>本网站就是使用hexo搭建的，增加了多说评论功能，自己改了点主题的bug，用起来还是比较舒服。</p><h2 id="Cmder"><a href="#Cmder" class="headerlink" title="Cmder"></a>Cmder</h2><p>Windows下非常好用的Linux终端。干净，漂亮，易于使用。</p><h2 id="MarkdownPad2"><a href="#MarkdownPad2" class="headerlink" title="MarkdownPad2"></a>MarkdownPad2</h2><p>Windows下很少有免费且好用的markdown编辑器，而现在又很流行使用markdown写文章或者word，这款软件是不错的选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一些好用的Windows工具。&lt;br&gt;
    
    </summary>
    
    
      <category term="分享" scheme="https://github.com/renhongl/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>电脑远程控制工具</title>
    <link href="https://github.com/renhongl/2016/12/04/%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    <id>https://github.com/renhongl/2016/12/04/电脑远程控制工具/</id>
    <published>2016-12-04T06:12:27.000Z</published>
    <updated>2019-01-01T03:19:18.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>今天分享的这个项目是用Python写的。通过手机远程控制电脑关机，或者接收指定的文件。</p><h2 id="图文介绍"><a href="#图文介绍" class="headerlink" title="图文介绍"></a>图文介绍</h2><p>通过输入简单的命令，就可以控制目标电脑，当别人在使用自己的电脑时，就可以远程关闭。如果想用来偷看别人电脑的信息，也是很方便的工具。只需要将程序复制到目标电脑中，双击运行一次，此程序就会在后台中悄悄运行，并且每次都会随电脑一起启动。接下来就可以获取此电脑的文件了。下面的第一张图片列出了所有符合的信息的具体地址，第二张拿的是具体的那几张图片。</p><p><img src="/images/pc2.png" alt="ap"></p><p><img src="/images/pc1.png" alt="ap"></p><p>源代码地址（<a href="https://github.com/renhongl/PCControl">点这里</a>） ，自己玩玩就好了。。别去偷看别人的隐私。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;今天分享的这个项目是用Python写的。通过手机远程控制电脑关机，或者接收指定的文件。&lt;/p&gt;
&lt;h2 id=&quot;图文介绍&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="分享" scheme="https://github.com/renhongl/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="Python" scheme="https://github.com/renhongl/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>应用平台WEB</title>
    <link href="https://github.com/renhongl/2016/11/24/%E5%BA%94%E7%94%A8%E5%B9%B3%E5%8F%B0WEB/"/>
    <id>https://github.com/renhongl/2016/11/24/应用平台WEB/</id>
    <published>2016-11-24T11:51:29.000Z</published>
    <updated>2019-01-01T03:14:00.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/homeAndRoom.png" alt="ap"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>项目涉及技术：RequireJS, Vue.js, NodeJS, Express, MongoDB, Bootstrap, WebSocket, JQuery, ES2015。</p><p>应用平台WEB版，是为了做一个网页版的APP store，也就是可以扩展出其他应用的一个平台。目前平台除了搭建了基本的结构之外，还做了一个简单的一对一聊天应用和简单的博客系统。下面将进行简单的介绍，源代码可在demo大师上下载：<a href="http://www.demodashi.com/demo/12539.html" target="_blank" rel="noopener">源码</a>，<a href="https://github.com/renhongl/ailiao">github点赞</a>。</p><h2 id="图文介绍"><a href="#图文介绍" class="headerlink" title="图文介绍"></a>图文介绍</h2><p><img src="/images/signIn.png" alt="ap"></p><p>这是登录页面，可以使用用户名和验证了的邮箱登录。</p><p><img src="/images/signUp.png" alt="ap"></p><p>这是注册页面，很简单的注册一下。 </p><p><img src="/images/resetPwd.png" alt="ap"></p><p>这是重置密码页面，需要通过验证邮箱的随机码，来实现重置密码。主要是通过后台服务器向邮箱发送信息。</p><p><img src="/images/chatHome.png" alt="ap"></p><p>这是主模块，包含登录用户的信息显示，并且可以随意设置。可以修改头像，设置状态，还可以添加邮箱，设置是否有消息提示音和提示框。还有就是显示自己的好友分组信息。可以任意修改分组。</p><p><img src="/images/homeAndRoom.png" alt="ap"></p><p>图的右边就是聊天的窗口，可以同时和多个人聊天，都会列在左边，点击就能切换聊天对象。窗口可以通过关闭所有聊天对象来关闭，或者通过右上角关闭按钮关闭。消息中可以发送一些表情。可以发送抖动窗口的消息。</p><p><img src="/images/docs.png" alt="ap"></p><p>这个应用是聊天主页的按钮点击出来的，可以显示一些简单的文档，并且可以点击喜欢某个文档，以及添加简单的评论信息。</p><h2 id="后端部分代码介绍"><a href="#后端部分代码介绍" class="headerlink" title="后端部分代码介绍"></a>后端部分代码介绍</h2><h3 id="Email-js"><a href="#Email-js" class="headerlink" title="Email.js"></a>Email.js</h3><p>用于发送邮件</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> 'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">'nodemailer'</span>);</span><br><span class="line"><span class="keyword">const</span> Config = <span class="built_in">require</span>(<span class="string">'./Config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(to, subject, text, html) &#123;</span><br><span class="line"><span class="keyword">this</span>.config = &#123;</span><br><span class="line">service: <span class="string">'126'</span>,</span><br><span class="line">auth: &#123;</span><br><span class="line">user: Config.EMAIL_SERVER,</span><br><span class="line">pass: Config.EMAIL_PWD            </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.mailOptions = &#123;</span><br><span class="line"><span class="keyword">from</span>: Config.EMAIL_SERVER,</span><br><span class="line">to: to,</span><br><span class="line">subject: subject,</span><br><span class="line">text: text,</span><br><span class="line"><span class="comment">//html: html</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>._send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_send() &#123;</span><br><span class="line"><span class="keyword">let</span> transporter = nodemailer.createTransport(<span class="keyword">this</span>.config);</span><br><span class="line">transporter.sendMail(<span class="keyword">this</span>.mailOptions, <span class="function"><span class="keyword">function</span> (<span class="params">error, info</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Message sent: '</span> + info.response);</span><br><span class="line">transporter.close();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Email;</span><br></pre></td></tr></table></figure><h3 id="Server-js"><a href="#Server-js" class="headerlink" title="Server.js"></a>Server.js</h3><p>作为服务器，并且是Websocket的父类。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'./Router'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(port)&#123;</span><br><span class="line">    <span class="keyword">this</span>.port = port;</span><br><span class="line">    <span class="keyword">this</span>.app = express();</span><br><span class="line">    <span class="keyword">this</span>.server = http.createServer(<span class="keyword">this</span>.app);</span><br><span class="line">    <span class="keyword">this</span>.io = socket.listen(<span class="keyword">this</span>.server);</span><br><span class="line">    <span class="keyword">this</span>._run();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _run()&#123;</span><br><span class="line">    <span class="keyword">this</span>.server.listen(<span class="keyword">this</span>.port);</span><br><span class="line">    <span class="keyword">this</span>.app.use(bodyParser.json());</span><br><span class="line">    <span class="keyword">this</span>.app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">    <span class="keyword">this</span>.app.use(express.static(__dirname.replace(<span class="regexp">/server\\core/</span>, <span class="string">'app'</span>)));</span><br><span class="line">    <span class="keyword">new</span> Router(<span class="keyword">this</span>.app);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'HTTP listening: 127.0.0.1:'</span> + <span class="keyword">this</span>.port);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Server;</span><br></pre></td></tr></table></figure><h3 id="User-js"><a href="#User-js" class="headerlink" title="User.js"></a>User.js</h3><p>和用户相关的所有接口都在这里。下面是一个获取验证码的接口，在获取请求后，会随机生成五位数验证码，发送到用户的邮箱中，并且在生成验证码的同时，会调用删除验证码的方法，在一定时间内将此验证码删除，那么用户就不能再使用此验证码修改密码了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_getCode()&#123;</span><br><span class="line">  <span class="keyword">this</span>.app.get(<span class="string">'/getCode'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> email = req.query.email;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      code += <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> queryData = &#123;</span><br><span class="line">      email: email</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> updateData = &#123;</span><br><span class="line">      code: code</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> callback = <span class="function">(<span class="params">db</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> collection = db.collection(<span class="keyword">this</span>.userCollection);</span><br><span class="line">      collection.updateOne(queryData, &#123;$<span class="keyword">set</span>: updateData&#125;, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">        assert.equal(<span class="literal">null</span>, err);</span><br><span class="line">        db.close();</span><br><span class="line">        <span class="keyword">if</span>(result.result.n === <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">new</span> Email(email, <span class="string">'重置密码'</span>, <span class="string">'你的验证码是：'</span> + code);</span><br><span class="line">          <span class="keyword">this</span>._removeCode(email);</span><br><span class="line">          res.send(&#123;status: <span class="string">'success'</span>, text: <span class="string">'验证码已发往你的邮箱，请查收。30分钟内有效。'</span>&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          res.send(&#123;status: <span class="string">'error'</span>, text: <span class="string">'没有此邮箱，或许你需要注册账号。'</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> MongoDB(<span class="keyword">this</span>.currentDB, callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端部分代码介绍"><a href="#前端部分代码介绍" class="headerlink" title="前端部分代码介绍"></a>前端部分代码介绍</h2><p>前端模块化采用的是RequireJS，AP_WEB2.0会使用Webpack,那时候会使用ES2015的模块管理。前端的代码较多，这里主要介绍下自己写的特别的功能。QueryString.js用户获取url上的参数信息。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">QueryString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">      <span class="keyword">let</span> search = <span class="built_in">window</span>.location.search.substring(<span class="number">1</span>).split(<span class="string">'&amp;'</span>);</span><br><span class="line">      <span class="keyword">let</span> tempGroup = [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> search) &#123;</span><br><span class="line">        tempGroup.push(p.split(<span class="string">'='</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.params = <span class="keyword">new</span> <span class="built_in">Map</span>(tempGroup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getValue(name)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.params.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> queryString = <span class="keyword">new</span> QueryString();</span><br><span class="line">  <span class="keyword">return</span> queryString;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Draggable-js"><a href="#Draggable-js" class="headerlink" title="Draggable.js"></a>Draggable.js</h3><p>用于添加拖动功能，在创建时，传入需要拖动的元素，这个元素就能拖动了。</p>  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">define([], function() &#123;</span><br><span class="line">  'use strict'<span class="comment">;</span></span><br><span class="line">  class Draggable &#123;</span><br><span class="line">    constructor($container) &#123;</span><br><span class="line">      this.$container = $container<span class="comment">;</span></span><br><span class="line">      for (<span class="name">let</span> subContainer of $container.children()) &#123;</span><br><span class="line">        this._handleEvents($(<span class="name">subContainer</span>))<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _handleEvents($subContainer) &#123;</span><br><span class="line">      $subContainer.on('mousedown', (<span class="name">e</span>) =&gt; &#123;</span><br><span class="line">        if (!$(<span class="name">e</span>.target).hasClass('button')) &#123;</span><br><span class="line">          this._handleMousedown(<span class="name">e</span>)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">      $(<span class="name">document</span>).on('mousemove', (<span class="name">e</span>) =&gt; &#123;</span><br><span class="line">        if (!$(<span class="name">e</span>.target).hasClass('button')) &#123;</span><br><span class="line">          this._handleMousemove(<span class="name">e</span>)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">      $(<span class="name">document</span>).on('mouseup', (<span class="name">e</span>) =&gt; &#123;</span><br><span class="line">        if (!$(<span class="name">e</span>.target).hasClass('button')) &#123;</span><br><span class="line">          this._handleMouseup(<span class="name">e</span>)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _handleMousedown(<span class="name">e</span>) &#123;</span><br><span class="line">      let &#123;left, top&#125; = this.$container.css(['left', 'top'])<span class="comment">;</span></span><br><span class="line">      this.offsetX = this._parseStr(<span class="name">left</span>) - e.clientX<span class="comment">;</span></span><br><span class="line">      this.offsetY = this._parseStr(<span class="name">top</span>) - e.clientY<span class="comment">;</span></span><br><span class="line">      this.mouseDown = true<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _handleMousemove(<span class="name">e</span>) &#123;</span><br><span class="line">      $(<span class="name">e</span>.target).css('cursor', 'url(<span class="name">/images/m1</span>.cur),default !important')<span class="comment">;</span></span><br><span class="line">      if (<span class="name">this</span>.mouseDown) &#123;</span><br><span class="line">        let x = e.clientX<span class="comment">;</span></span><br><span class="line">        let y = e.clientY<span class="comment">;</span></span><br><span class="line">        let positionX = x + this.offsetX<span class="comment">;</span></span><br><span class="line">        let positionY = y + this.offsetY<span class="comment">;</span></span><br><span class="line">        this.$container.css(&#123;</span><br><span class="line">          left: positionX,</span><br><span class="line">          top: positionY,</span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _handleMouseup(<span class="name">e</span>) &#123;</span><br><span class="line">      $(<span class="name">e</span>.target).css('cursor', 'url(<span class="name">/images/m1</span>.cur),default !important')<span class="comment">;</span></span><br><span class="line">      this.mouseDown = false<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _parseStr(<span class="name">str</span>) &#123;</span><br><span class="line">      if(<span class="name">typeof</span> str !== 'string')&#123;</span><br><span class="line">        str += ''<span class="comment">; </span></span><br><span class="line">      &#125;</span><br><span class="line">      return Number(<span class="name">str</span>.split('px')[<span class="number">0</span>])<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Draggable<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="Rain-js"><a href="#Rain-js" class="headerlink" title="Rain.js"></a>Rain.js</h3><p>用于添加鼠标点击效果，创建之后，在整个网页中，除了class中有button的元素，其他都会在点击时，出现像雨滴落在地上的效果。</p>  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">define([], function() &#123;</span><br><span class="line">  'use strict'<span class="comment">;</span></span><br><span class="line">  class Rain &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      this.settings = &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">10</span>,</span><br><span class="line">        borderColor: '#c6cac9',</span><br><span class="line">        opacity: <span class="number">0.7</span>,</span><br><span class="line">        borderRadius: <span class="number">5</span>,</span><br><span class="line">        borderWidth: <span class="number">5</span>,</span><br><span class="line">        maxWidth: <span class="number">70</span>,</span><br><span class="line">        widthOffset: <span class="number">2</span>,</span><br><span class="line">        radiusOffset: <span class="number">1</span>,</span><br><span class="line">        opacityOffset: <span class="number">0.05</span>,</span><br><span class="line">        borderOffset: <span class="number">1</span>,</span><br><span class="line">        position: 'fixed',</span><br><span class="line">        zIndex: <span class="number">100</span>,</span><br><span class="line">        borderStyle: 'solid',</span><br><span class="line">        class: 'rain',</span><br><span class="line">      &#125;<span class="comment">;</span></span><br><span class="line">      this._handleEvents()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _handleEvents() &#123;</span><br><span class="line">      let settings = this.settings<span class="comment">;</span></span><br><span class="line">      $(<span class="name">document</span>).on('click', (<span class="name">e</span>) =&gt; &#123;</span><br><span class="line">        if($(<span class="name">e</span>.target).hasClass('button'))&#123;</span><br><span class="line">          return<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        let $rain = $('&lt;div&gt;').attr('class', settings.class).css(&#123;</span><br><span class="line">          position: settings.position,</span><br><span class="line">          zIndex: settings.zIndex,</span><br><span class="line">          borderStyle: settings.borderStyle,</span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">        $('body').append($rain)<span class="comment">;</span></span><br><span class="line">        let x = e.clientX<span class="comment">;</span></span><br><span class="line">        let y = e.clientY<span class="comment">;</span></span><br><span class="line">        this._initRain($rain, x, y)<span class="comment">;</span></span><br><span class="line">        this._updateRain($rain, x, y)<span class="comment">;</span></span><br><span class="line">      &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _updateRain($rain, x, y) &#123;</span><br><span class="line">      let settings = this.settings<span class="comment">;</span></span><br><span class="line">      let rainThread = setInterval( () =&gt; &#123;</span><br><span class="line">        let &#123;width, height,top, left, opacity, borderWidth, borderRadius&#125; = $rain.css(['width', 'height','top', 'left', 'opacity', 'borderWidth', 'borderRadius'])<span class="comment">;</span></span><br><span class="line">        $rain.css(&#123;</span><br><span class="line">          width: this._parseStr(<span class="name">width</span>) + settings.widthOffset,</span><br><span class="line">          height: this._parseStr(<span class="name">height</span>) + settings.widthOffset,</span><br><span class="line">          top: y - this._parseStr(<span class="name">height</span>) / <span class="number">2</span>,</span><br><span class="line">          left: x - this._parseStr(<span class="name">width</span>) / <span class="number">2</span>,</span><br><span class="line">          opacity: this._parseStr(<span class="name">opacity</span>) - settings.opacityOffset,</span><br><span class="line">          borderWidth: this._parseStr(<span class="name">borderWidth</span>) + settings.borderOffset,</span><br><span class="line">          borderRadius: this._parseStr(<span class="name">borderRadius</span>) + settings.radiusOffset,</span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">        if (<span class="name">this</span>._parseStr(<span class="name">width</span>) &gt; settings.maxWidth) &#123;</span><br><span class="line">          clearInterval(<span class="name">rainThread</span>)<span class="comment">;</span></span><br><span class="line">          $rain.remove()<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _initRain($rain, x, y) &#123;</span><br><span class="line">      let settings = this.settings<span class="comment">;</span></span><br><span class="line">      $rain.css(&#123;</span><br><span class="line">        width: settings.width,</span><br><span class="line">        height: settings.height,</span><br><span class="line">        borderColor: settings.borderColor,</span><br><span class="line">        opacity: settings.opacity,</span><br><span class="line">        borderRadius: settings.borderRadius,</span><br><span class="line">        borderWidth: settings.borderWidth,</span><br><span class="line">        top: y - this._parseStr(<span class="name">settings</span>.height) / <span class="number">2</span>,</span><br><span class="line">        left: x - this._parseStr(<span class="name">settings</span>.width) / <span class="number">2</span>,</span><br><span class="line">      &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _parseStr(<span class="name">str</span>)&#123;</span><br><span class="line">      if(<span class="name">typeof</span> str !== 'string')&#123;</span><br><span class="line">        str += ''<span class="comment">; </span></span><br><span class="line">      &#125;</span><br><span class="line">      return Number(<span class="name">str</span>.split('px')[<span class="number">0</span>])<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Rain<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="Message-js"><a href="#Message-js" class="headerlink" title="Message.js"></a>Message.js</h3><p>最后一个要介绍的是Message.js，它是一个全局提示的工具，项目中使用它做ajax返回信息的控制，做聊天室消息预览等。当有一些信息要发送给用户时，会在浏览器的右上角出现对话框，包含信息标题，信息内容等。并且分为几种类型的提示，不同类型会有不同主题的对话框出现。由于代码太多，这里只列出了它的构造方法。</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(type, content) &#123;</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">this</span>.content = content;</span><br><span class="line">  <span class="keyword">this</span>.showTime = <span class="number">5000</span>;</span><br><span class="line">  <span class="keyword">this</span>.clearTime = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">this</span>.clearThread = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.timeThread = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.$Message = $(<span class="string">'&lt;div&gt;'</span>).css(&#123;</span><br><span class="line">    color: <span class="string">'#fff'</span>,</span><br><span class="line">    borderRadius: <span class="number">5</span>,</span><br><span class="line">    width: <span class="number">300</span>,</span><br><span class="line">    display: <span class="string">'none'</span>,</span><br><span class="line">    zIndex: <span class="number">110</span>,</span><br><span class="line">    margin: <span class="string">'2px 5px'</span>,</span><br><span class="line">    clear: <span class="string">'both'</span>,</span><br><span class="line">    float: <span class="string">'right'</span>,</span><br><span class="line">    position: <span class="string">'relative'</span>,</span><br><span class="line">    boxShadow: <span class="string">'0px 0px 10px rgba(255, 255, 255, 1)'</span>,</span><br><span class="line">    opacity: <span class="number">0.9</span>,</span><br><span class="line">  &#125;).addClass(<span class="string">'message'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.$icon = $(<span class="string">'&lt;i&gt;'</span>).css(&#123;</span><br><span class="line">    display: <span class="string">'inline-block'</span>,</span><br><span class="line">    float: <span class="string">'left'</span>,</span><br><span class="line">    marginLeft: <span class="number">10</span>,</span><br><span class="line">    width: <span class="number">20</span>,</span><br><span class="line">    textAlign: <span class="string">'center'</span>,</span><br><span class="line">    fontSize: <span class="string">'1.2em'</span>,</span><br><span class="line">  &#125;).addClass(<span class="string">'msgIcon'</span>).appendTo(<span class="keyword">this</span>.$Message);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.$title = $(<span class="string">'&lt;div&gt;'</span>).css(&#123;</span><br><span class="line">    height: <span class="string">'45%'</span>,</span><br><span class="line">    width: <span class="number">260</span>,</span><br><span class="line">    float: <span class="string">'right'</span>,</span><br><span class="line">    fontSize: <span class="string">'1.2em'</span>,</span><br><span class="line">  &#125;).addClass(<span class="string">'msgTitle'</span>).appendTo(<span class="keyword">this</span>.$Message);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.$time = $(<span class="string">'&lt;span&gt;'</span>).css(&#123;</span><br><span class="line">    position: <span class="string">'absolute'</span>,</span><br><span class="line">    top: <span class="number">2</span>,</span><br><span class="line">    right: <span class="number">2</span>,</span><br><span class="line">    fontSize: <span class="string">'0.7em'</span>,</span><br><span class="line">  &#125;).addClass(<span class="string">'msgTime'</span>).appendTo(<span class="keyword">this</span>.$Message);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.$content = $(<span class="string">'&lt;div&gt;'</span>).css(&#123;</span><br><span class="line">    float: <span class="string">'right'</span>,</span><br><span class="line">    height: <span class="string">'56%'</span>,</span><br><span class="line">    width: <span class="number">260</span>,</span><br><span class="line">    paddingBottom: <span class="number">5</span>,</span><br><span class="line">    paddingRight: <span class="number">5</span>,</span><br><span class="line">    fontSize: <span class="string">'0.8em'</span>,</span><br><span class="line">  &#125;).addClass(<span class="string">'msgContent'</span>).appendTo(<span class="keyword">this</span>.$Message);</span><br><span class="line">  </span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case <span class="string">'infor'</span>:</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'提示'</span>;</span><br><span class="line">      <span class="keyword">this</span>._infor();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    case <span class="string">'success'</span>:</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'成功'</span>;</span><br><span class="line">      <span class="keyword">this</span>._success();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    case <span class="string">'error'</span>:</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'错误'</span>;</span><br><span class="line">      <span class="keyword">this</span>._error();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    case <span class="string">'warning'</span>:</span><br><span class="line">      <span class="keyword">this</span>.title = <span class="string">'警告'</span>;</span><br><span class="line">      <span class="keyword">this</span>._warning();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    case <span class="string">'message'</span>:</span><br><span class="line">      <span class="keyword">this</span>._message();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写代码很重要，调试也很重要，好的调试方法，可以更快的发现、解决问题。正视错误，用积极的态度去处理错误，会提升自己面临问题时的处理能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/homeAndRoom.png&quot; alt=&quot;ap&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;项目涉及技术：RequireJS, 
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://github.com/renhongl/tags/Javascript/"/>
    
      <category term="分享" scheme="https://github.com/renhongl/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>应用平台桌面版</title>
    <link href="https://github.com/renhongl/2016/11/15/%E5%BA%94%E7%94%A8%E5%B9%B3%E5%8F%B0%E6%A1%8C%E9%9D%A2%E7%89%88/"/>
    <id>https://github.com/renhongl/2016/11/15/应用平台桌面版/</id>
    <published>2016-11-15T14:16:38.000Z</published>
    <updated>2019-01-01T03:14:25.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用web技术开发的应用平台。</p><p>可以将所有应用装在一起，只需要登录一次，就能用所有的应用。效果图如下：</p><p><img src="/images/applicationPlatform.png" alt="ap"></p><p>目前做了三个应用，音乐播放器，多人聊天室，爱心鱼游戏。下面将<br>会详细介绍它们。</p><p>因为我写了一小部分后台，所以运行前需要启动服务器。在下载完<br>源码后，打开一个cmd窗口，进入根目录，运行代码：</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">server</span>.js</span><br></pre></td></tr></table></figure><p>将服务器跑起来。然后再打开一个cmd窗口，运行代码：</p>  <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> start</span><br></pre></td></tr></table></figure><p>应用就打开了。</p><h2 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h2><p>它只包含基本的功能：导入本地歌曲列表；切换一个主题；控制正在播放的歌曲。<br>效果图如下：</p><p><img src="/images/musicPlayer2.png" alt="ap"></p><p>UX方面做得不是很好，以后会更加注重这一块。</p><h2 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h2><p>聊天室是我觉得做得比较好的一个，因为它包含了很多功能。<br>除了最基本的聊天外，还支持发一些表情，还可以设置字体，背景，以及主题。<br>里面还集成了一个地图，如果是用电脑浏览器打开的，将会在地图上显示自己的<br>位置。效果图如下：</p><p><img src="/images/chatRoom2.png" alt="ap"></p><h2 id="爱心鱼"><a href="#爱心鱼" class="headerlink" title="爱心鱼"></a>爱心鱼</h2><p>最后一个是个用js写的游戏，但这并不是原创，只是用来熟悉canvas的api。<br>效果图如下：</p><p><img src="/images/loveFish.png" alt="ap"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些是我刚学Javascript不久做的东西，所以有很多地方不够完善。但是它们让我看到了Javascript强大的一面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;使用web技术开发的应用平台。&lt;/p&gt;
&lt;p&gt;可以将所有应用装在一起，只需要登录一次，就能用所有的应用。效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://github.com/renhongl/tags/Javascript/"/>
    
      <category term="分享" scheme="https://github.com/renhongl/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
